{
  "version": 3,
  "sources": ["../../fatfs-wasm/src/fatfs.ts"],
  "sourcesContent": ["/**\n * High-level interface for creating and accessing FAT images using the FatFS library by CHaN.\n * @module fatfs-wasm\n */\n\n/* CONSTANTS */\n\n/** Disk I/O control commands (for disk_ioctl) */\nexport enum FatFsIoctl {\n    CTRL_SYNC = 0,\n    GET_SECTOR_COUNT = 1,\n    GET_SECTOR_SIZE = 2,\n    GET_BLOCK_SIZE = 3,\n    CTRL_TRIM = 4\n}\n\n/** Format options (2nd argument of f_mkfs) */\nexport enum FatFsFormat {\n    FAT = 1,\n    FAT32 = 2,\n    EXFAT = 4,\n    ANY = 7,\n    SFD = 8\n}\n\n/* File function return code (FRESULT) */\nexport enum FatFsResult {\n    OK = 0,                    /** (0) Succeeded */\n    DISK_ERR = 1,              /** (1) A hard error occurred in the low level disk I/O layer */\n    INT_ERR = 2,               /** (2) Assertion failed */\n    NOT_READY = 3,             /** (3) The physical drive cannot work */\n    NO_FILE = 4,               /** (4) Could not find the file */\n    NO_PATH = 5,               /** (5) Could not find the path */\n    INVALID_NAME = 6,          /** (6) The path name format is invalid */\n    DENIED = 7,                /** (7) Access denied due to prohibited access or directory full */\n    EXIST = 8,                 /** (8) Access denied due to prohibited access */\n    INVALID_OBJECT = 9,        /** (9) The file/directory object is invalid */\n    WRITE_PROTECTED = 10,      /** (10) The physical drive is write protected */\n    INVALID_DRIVE = 11,        /** (11) The logical drive number is invalid */\n    NOT_ENABLED = 12,          /** (12) The volumeF has no work area */\n    NO_FILESYSTEM = 13,        /** (13) There is no valid FAT volume */\n    MKFS_ABORTED = 14,         /** (14) The f_mkfs() aborted due to any problem */\n    TIMEOUT = 15,              /** (15) Could not get a grant to access the volume within defined period */\n    LOCKED = 16,               /** (16) The operation is rejected according to the file sharing policy */\n    NOT_ENOUGH_CORE = 17,      /** (17) LFN working buffer could not be allocated */\n    TOO_MANY_OPEN_FILES = 18,  /** (18) Number of open files > FF_FS_LOCK */\n    INVALID_PARAMETER = 19     /** (19) Given parameter is invalid */\n}\n\n/** File attribute bits for directory entry (FILINFO.fattrib) */\nexport enum FatFsAttrib {\n    RDO = 0x01,\n    HID = 0x02,\n    SYS = 0x04,\n    DIR = 0x10,\n    ARC = 0x20\n}\n\n/** File modes */\nexport enum FatFsMode {\n    /** \n     * Specifies read access to the file. Data can be read from the file. \n     */\n    READ = 0x1,\n    /**\n     * Specifies write access to the file. Data can be written to the file. \n     * Combine with FA_READ for read-write access.\n     */\n    WRITE = 0x2,\n    /**\n     * Opens a file. The function fails if the file is not existing. (Default)\n     */\n    OPEN_EXISTING = 0x0,\n    /**\n     * Creates a new file. The function fails with FR_EXIST if the file is \n     * existing.\n     */\n    CREATE_NEW = 0x4,\n    /**\n     * Creates a new file. If the file is existing, it will be truncated and \n     * overwritten.\n     */\n    CREATE_ALWAYS = 0x8,\n    /**\n     * Opens the file if it is existing. If not, a new file will be created.\n     */\n    OPEN_ALWAYS = 0x10,\n    /**\n     * Same as FA_OPEN_ALWAYS except the read/write pointer is set end of the \n     * file.\n     */\n    OPEN_APPEND = 0x30\n}\n\nconst FF_MAX_SS = 512;           // Max sector size (must match ffconf.h) \nconst DEFAULT_SECTOR_SIZE = 512; // Default sector size \nconst SIZE_FILINFO = 24;\nconst SIZE_FATFS_OBJ = 560;\nconst SIZE_FIL = 576;\nconst SIZE_DIR = 64\nconst OFFSET_FATFS_CSIZE = 10;\n\n/* HELPER FUNCTIONS */\n\n// URL resolution must be at the top level because the \n// UMD polyfill for import.meta.url uses document.currentSource.src.\nconst singleWasmUrl = new URL('./ff_multi.wasm', import.meta.url);\nconst multiWasmUrl = new URL('./ff_single.wasm', import.meta.url);\nasync function getWasm(importObject: WebAssembly.Imports, options: FatFsDiskOptions) {\n    const wasmUrl = options?.multiPartition ? singleWasmUrl : multiWasmUrl;\n    if (typeof window !== 'undefined') { // Browser\n        return await WebAssembly.instantiateStreaming(fetch(wasmUrl), importObject);\n    } else { // Node\n        const { readFile } = await import('node:fs/promises');\n        const { fileURLToPath } = await import('node:url');\n        const wasmData = await readFile(fileURLToPath(wasmUrl));\n        return await WebAssembly.instantiate(wasmData, importObject);\n    }\n};\n\nfunction throwIfError(actionName: string, action: () => FatFsResult, onError?: () => void) {\n    const result = action();\n    if (result !== FatFsResult.OK) {\n        onError?.();\n        throw new FatFsError(actionName, result);\n    }\n}\n\nfunction createImportObject(\n    memory: WebAssembly.Memory,\n    disk: Uint8Array,\n    sectorSize?: number\n): WebAssembly.Imports {\n    const ss = (sectorSize ?? DEFAULT_SECTOR_SIZE) | 0;\n    const sectorCount = (disk.byteLength / ss) | 0;\n\n    return {\n        env: {\n            memory: memory,\n            disk_initialize: (pdrv: number) => {\n                return FatFsResult.OK;\n            },\n            disk_status: (pdrv: number) => {\n                return FatFsResult.OK;\n            },\n            disk_read: (pdrv: number, buff: number, sector: number, count: number) => {\n                const src = disk.subarray(sector * ss, (sector + count) * ss);\n                const heap = new Uint8Array(memory.buffer);\n                heap.set(src, buff);\n                return FatFsResult.OK;\n            },\n            disk_write: (pdrv: number, buff: number, sector: number, count: number) => {\n                const heap = new Uint8Array(memory.buffer);\n                const src = heap.subarray(buff, buff + (count * ss));\n                disk.set(src, sector * ss);\n                return FatFsResult.OK;\n            },\n            disk_ioctl: (pdrv: number, cmd: number, buff: number) => {\n                const view = new DataView(memory.buffer);\n                switch (cmd) {\n                    case FatFsIoctl.CTRL_SYNC:\n                        // Nothing to do for this command if each write operation \n                        // to the medium is completed in the disk_write function\n                        break; \n                    case FatFsIoctl.GET_SECTOR_SIZE:\n                        view.setUint16(buff, ss, true);\n                        break;\n                    case FatFsIoctl.GET_SECTOR_COUNT:\n                        view.setUint32(buff, sectorCount, true); \n                        break; \n                    case FatFsIoctl.GET_BLOCK_SIZE:\n                        return 1; // unknown/non-flash media\n                    case FatFsIoctl.CTRL_TRIM:\n                        // Nothing to do for this command if this funcion is not \n                        // supported or not a flash memory device\n                        break;\n                    default:\n                        break;\n                }\n                return FatFsResult.OK;\n            },\n            get_fattime: () => {\n                const date = new Date();\n                const year = (date.getFullYear() - 1980) % 128;\n                const month = date.getMonth() + 1;\n                const day = date.getDay();\n                const hour = date.getHours();\n                const minute = date.getMinutes();\n                const second = date.getSeconds() >> 1;\n                return (\n                    (year << 25) | \n                    (month << 21) |\n                    (day << 16) |\n                    (hour << 11) |\n                    (minute << 5) |\n                    second);\n            }\n        }\n    }\n}\n\n\n/* STRUCTURES */\n\ntype FatFsExports = {\n    malloc: (size: number) => number;\n    free: (ptr: number) => void;\n    f_fdisk: (pdrv: number, ptbl: number, work: number) => number;\n    f_mkfs: (path: number, opt: number, work: number, len: number) => number;\n    f_mount: (fs: number, path: number, opt: number) => number;\n    f_open: (fp: number, path: number, mode: number) => number;\n    f_read: (fp: number, buff: number, btr: number, br: number) => number;\n    f_write: (fp: number, buff: number, btw: number, bw: number) => number;\n    f_close: (fp: number) => number;\n    f_sync: (fp: number) => number;\n    f_lseek: (fp: number, ofs: number) => number;\n    f_truncate: (fp: number) => number;\n    f_expand: (fp: number, fsz: number, opt: number) => number;\n    f_gets: (buff: number, len: number, fp: number) => number;\n    f_putc: (chr: number, fp: number) => number;\n    f_puts: (str: number, fp: number) => number;\n    f_tell: (fp: number) => number;\n    f_eof: (fp: number) => number;\n    f_size: (fp: number) => number;\n    f_error: (fp: number) => number;\n    f_opendir: (dp: number, path: number) => number;\n    f_closedir: (dp: number) => number;\n    f_readdir: (dp: number, fno: number) => number;\n    f_findfirst: (dp: number, fno: number, path: number, pattern: number) => number;\n    f_findnext: (dp: number, fno: number) => number;\n    f_stat: (path: number, fno: number) => number;\n    f_unlink: (path: number) => number;\n    f_rename: (oldName: number, newName: number) => number;\n    f_chmod: (path: number, attr: number, mask: number) => number;\n    f_utime: (path: number, fno: number) => number;\n    f_mkdir: (path: number) => number;\n    f_chdir: (path: number) => number;\n    f_chdrive: (path: number) => number;\n    f_getcwd: (buff: number, len: number) => number;\n    f_getfree: (path: number, nclst: number, fatfs: number) => number;\n    f_getlabel: (path: number, label: number, vsn: number) => number;\n    f_setlabel: (label: number) => number;\n    f_setcp: (cp: number) => number;\n}\n\ntype HeapScope = {\n    alloc: (size: number) => number;\n    allocString: (text: string | null) => number;\n};\n\n/**\n * Options provided to {@link FatFsDisk.mkfs}\n */\nexport type FatFsMkfsOptions = {\n\t/** Format option (FM_FAT, FM_FAT32, FM_EXFAT and FM_SFD) */\n    fmt?: FatFsFormat;\t\n\t/** Number of FATs */\n    nFat?: number;\t\t\n\t/** Data area alignment (sector) */\n    align?: number;\t\t\n\t/** Number of root directory entries */\n    nRoot?: number;\t\t\n\t/** Cluster size (byte) */\n    auSize?: number;\t\n    /** Drive number to format. Empty string uses default drive */\n    path?: string;      \n}\n\nclass FatFsObject {\n    #fatFsPtr: number;\n    #context: FatFsMemoryContext;\n    constructor(fatFsPtr: number, context: FatFsMemoryContext) {\n        this.#fatFsPtr = fatFsPtr;\n        this.#context = context;\n    }\n\n    get ptr(): number {\n        return this.#fatFsPtr;\n    }\n\n    /**\n     * Sectors per cluster\n     */\n    get cSize(): number {\n        return this.#context.view.getUint16(this.#fatFsPtr + OFFSET_FATFS_CSIZE, true);\n    }\n}\n\nclass FatFsMemoryContext {\n    #memory: WebAssembly.Memory;\n    #exports: FatFsExports;\n\n    constructor(memory: WebAssembly.Memory, exports: FatFsExports) {\n        this.#memory = memory;\n        this.#exports = exports;\n    }\n\n    get heap() {\n        return new Uint8Array(this.#memory.buffer);\n    }\n\n    get view() {\n        return new DataView(this.#memory.buffer);\n    }\n\n    allocString(text: string | null): number {\n        if (typeof text === 'undefined' || text === null)\n            return 0;\n        const textBytes = new TextEncoder().encode(text);\n        const textPtr = this.alloc(textBytes.length + 1);\n        const textArray = this.heap.subarray(textPtr, textPtr + textBytes.length + 1);\n        textArray.set(textBytes);\n        textArray[textArray.length - 1] = 0;\n        return textPtr;\n    }\n\n    alloc(size: number): number {\n        return this.#exports.malloc(size);\n    }\n\n    free(ptr: number): void {\n        this.#exports.free(ptr);\n    }\n\n    decodeString(buffer: number, size: number): string {\n        const ptrArray = this.heap.subarray(buffer, buffer + size);\n        const zeroIndex = ptrArray.indexOf(0);\n        const ptrTrimmed = zeroIndex >= 0\n            ? ptrArray.subarray(0, zeroIndex)\n            : ptrArray;\n        return new TextDecoder().decode(ptrTrimmed);\n    }\n\n    enterScope<T>(callback: (scope: HeapScope) => T) {\n        const resources: number[] = [];\n        const scope = {\n            alloc: (size: number) => {\n                const ptr = this.alloc(size);\n                resources.unshift(ptr);\n                return ptr;\n            },\n            allocString: (text: string | null) => {\n                const ptr = this.allocString(text);\n                resources.unshift(ptr);\n                return ptr;\n            }\n        };\n        try {\n            return callback(scope);\n        } finally {\n            for (const ptr of resources) {\n                this.free(ptr);\n            }\n        }\n    }\n}\n\n/**\n * Represents file or directory information returned from {@link FatFsDisk.stat} and iteration functions.\n */\nexport class FatFsFileInfo {\n    /** The size of the file or directory */\n    readonly size: number; \n    /** The last modified date of the file or directory */\n    readonly date: Date; \n    /** File attribute flags (see is* methods to get specific flags) */\n    readonly attrib: number; \n    /** The name of the file or directory */\n    readonly name: string; \n\n    constructor(size: number, date: Date, attrib: number, name: string) {\n        this.size = size;\n        this.date = date;\n        this.attrib = attrib;\n        this.name = name;\n    }\n\n    /** \n     * Creates a {@link FatFsFileInfo} from a packed FILINFO data structure returned from a FatFS function \n     * @data Packed FILINFO structure bytes\n     */\n    static fromFilInfo(data: Uint8Array): FatFsFileInfo {\n        const view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n        const size = view.getUint32(0, true);\n\n        const encodedDate = view.getUint16(4, true);\n        const year = 1980 + ((encodedDate & 0xFE00) >> 9);\n        const month = ((encodedDate & 0x01E0) >> 5) - 1;\n        const day = encodedDate & 0x001F;\n        const encodedTime = view.getUint16(6, true);\n        const hour = (encodedTime & 0xF800) >> 11;\n        const minute = (encodedTime & 0x07E0) >> 5;\n        const second = (encodedTime & 0x001F) * 2;\n        const date = new Date(year, month, day, hour, minute, second);\n        \n        const attrib = data[8];\n\n        const nameArray = data.subarray(9, 22);\n        const zeroIndex = nameArray.indexOf(0);\n        const nameTrimmed = zeroIndex >= 0\n            ? nameArray.subarray(0, zeroIndex)\n            : nameArray;\n        const name = new TextDecoder().decode(nameTrimmed);\n\n        return new FatFsFileInfo(size, date, attrib, name);\n    }\n\n    /**\n     * Whether or not the file or directory is read-only\n     */\n    get isReadOnly(): boolean { return !!(this.attrib & FatFsAttrib.RDO); }\n\n    /**\n     * Whether or not the filesystem object is a directory or not\n     */\n    get isDirectory(): boolean { return !!(this.attrib & FatFsAttrib.DIR); }\n\n    /**\n     * Whether or not the file or directory is hidden\n     */\n    get isHidden(): boolean { return !!(this.attrib & FatFsAttrib.HID); }\n\n    /**\n     * Whether or not the file or directory is archived\n     */\n    get isArchive(): boolean { return !!(this.attrib & FatFsAttrib.ARC); }\n\n    /**\n     * Whether or not the file or directory is a system file or directory\n     */\n    get isSystem(): boolean { return !!(this.attrib & FatFsAttrib.SYS); }\n}\n\n/** Exception thrown when a FatFs export returns a non-OK result */\nexport class FatFsError extends Error {\n    result: FatFsResult;\n    constructor(action: string, errorCode: FatFsResult) {\n        const message = `Error ${action}: ${FatFsResult[errorCode]} (${errorCode})`;\n        super(message);\n        Object.setPrototypeOf(this, FatFsError.prototype);\n        this.result = errorCode;\n    }\n}\n\n/**\n * FatFs file object\n */\nexport class FatFsFile {\n    #filePtr: number;\n    #exports: FatFsExports;\n    #context: FatFsMemoryContext;\n\n    constructor(\n        filePtr: number,\n        exports: FatFsExports,\n        context: FatFsMemoryContext\n    ) {\n        this.#filePtr = filePtr;\n        this.#exports = exports;\n        this.#context = context;\n    }\n\n    /** \n     * Low level pointer to the file descriptor\n     */\n    get fp() {\n        return this.#filePtr;\n    }\n\n    /**\n     * The f_read function reads data from a file.\n     * @param buff Pointer to the buffer to store the read data.\n     * @param btr Number of bytes to read in range of UINT type. If the file needs to be read fast, it should be read in large chunk as possible.\n     * @returns number of bytes read\n     */\n    read(buff: Uint8Array, btr?: number): number {\n        const f_read = this.#exports.f_read;\n        const filePtr = this.#filePtr;\n        const bytesToRead = btr ?? buff.length;\n        return this.#context.enterScope((scope) => {\n            const buffPtr = scope.alloc(bytesToRead);\n            const brPtr = scope.alloc(4);\n            throwIfError(\n                \"reading file\",\n                () => f_read(filePtr, buffPtr, bytesToRead, brPtr)\n            );\n            const bytesRead = this.#context.view.getUint32(brPtr, true);\n            buff.set(this.#context.heap.subarray(buffPtr, buffPtr + bytesRead));\n            return bytesRead;\n        });\n    }\n\n    /**\n     * The f_write writes data to a file.\n     * @param buff Pointer to the data to be written.\n     * @param btw Specifies number of bytes to write in range of UINT type. If \n     *     the data needs to be written fast, it should be written in large \n     *     chunk as possible.\n     * @returns number of bytes written\n     */\n    write(buff: Uint8Array, btw?: number): number {\n        return this.#context.enterScope(scope => {\n            const bytesToWrite = btw ?? buff.length;\n            const buffPtr = scope.alloc(bytesToWrite);\n            const bwPtr = scope.alloc(4);\n            this.#context.heap.subarray(buffPtr, buffPtr + bytesToWrite).set(buff);\n            throwIfError(\n                \"writing file\",\n                () => this.#exports.f_write(this.#filePtr, buffPtr, bytesToWrite, bwPtr)\n            );\n            return this.#context.view.getUint32(bwPtr, true);\n        });\n    }\n\n    /**\n     * The f_close function closes an open file and destroys the file object.\n     */\n    close(): void {\n        try {\n            throwIfError(\n                \"closing file\",\n                () => this.#exports.f_close(this.#filePtr)\n            );\n        } finally {\n            this.#exports.free(this.#filePtr);\n        }\n    }\n    \n    /**\n     * The f_sync function flushes the cached information of a writing file.\n     */\n    sync(): void {\n        throwIfError(\n            \"syncing disk\",\n            () => this.#exports.f_sync(this.#filePtr)\n        );\n    } \n    \n    /**\n     * The f_lseek function moves the file read/write pointer of an open file \n     * object. It can also be used to expand the file size \n     * (cluster pre-allocation).\n     * @param ofs Byte offset from top of the file to set read/write pointer. \n     *     The data type FSIZE_t is an alias of either DWORD(32-bit) or \n     *     QWORD(64-bit) depends on the configuration option FF_FS_EXFAT.\n     */\n    lseek(ofs: number): void {\n        throwIfError(\n            \"seeking\",\n            () => this.#exports.f_lseek(this.#filePtr, ofs)\n        );\n    }\n\n    rewind(): void {\n        this.lseek(0);\n    }\n\n    /**\n     * The f_truncate function truncates the file size to the current file \n     * read/write pointer.\n     */\n    truncate(): void {\n        throwIfError(\n            \"truncating file\",\n            () => this.#exports.f_truncate(this.#filePtr)\n        );\n    }\n\n    /**\n     * The f_expand function prepares or allocates a contiguous data area to \n     * the file.\n     * @param fsz Number of bytes in size to prepare or allocate for the file. \n     *     The data type FSIZE_t is an alias of either DWORD(32-bit) or \n     *     QWORD(64-bit) depends on the configuration option FF_FS_EXFAT.\n     * @param opt Allocation mode. Prepare to allocate (0) or Allocate now (1).\n     */\n    expand(fsz: number, opt: number): void {\n        throwIfError(\n            \"expanding file\",\n            () => this.#exports.f_expand(this.#filePtr, fsz, opt)\n        );\n    }\n\n    /**\n     * The f_gets reads a string from the file.\n     * @returns the string\n     */\n    gets(maxSize: number): string {\n        return this.#context.enterScope(scope => {\n            const buffPtr = scope.alloc(maxSize + 1);\n            throwIfError(\n                \"reading string from file\",\n                () => this.#exports.f_gets(buffPtr, maxSize, this.#filePtr)\n            );\n            return this.#context.decodeString(buffPtr, maxSize + 1);\n        });\n    }\n\n    /**\n     * The f_putc function puts a character to the file.\n     * @param chr A code unit to write.\n     * @returns When the character was written successfuly, it returns number \n     *     of character encoding units written to the file. When the function \n     *     failed due to disk full or any error, a negative value will be returned.\n     */\n    putc(chr: number): number {\n        const chrCode = chr % 256;\n        return this.#exports.f_putc(chrCode, this.#filePtr);\n    }\n\n    /**\n     * The f_puts function writes a string to the file.\n     * @param str Pointer to the null terminated string to be written. The \n     *     terminator character will not be written.\n     * @returns When the string was written successfuly, it returns number \n     *     of character encoding units written to the file. When the function \n     *     failed due to disk full or any error, a negative value will be \n     *     returned.\n     */\n    puts(str: string): number {\n        const f_puts = this.#exports.f_puts as (str: number, fp: number) => number;\n        return this.#context.enterScope(scope => {\n            const strPtr = scope.allocString(str);\n            return f_puts(strPtr, this.#filePtr);\n        });\n    }\n\n    /**\n     * The f_tell function gets the current read/write pointer of a file.\n     * @returns Returns current read/write pointer of the file.\n     */\n    tell(): number {\n        return this.#exports.f_tell(this.#filePtr);\n    }\n\n    /**\n     * The f_eof function tests for end-of-file on a file.\n     * @returns The f_eof function returns a non-zero value \n     *     if the read/write pointer has reached end of the file; otherwise it\n     *     returns a zero.\n     */\n    eof(fp: FatFsFile): number {\n        return this.#exports.f_eof(this.#filePtr);\n    }\n\n    /**\n     * The f_size function gets the size of a file.\n     * @returns Returns the size of the file in unit of byte.\n     */\n    size(): number {\n        return this.#exports.f_size(this.#filePtr);\n    }\n\n    /**\n     * The f_error tests for an error on a file.\n     * @returns Returns a non-zero value if a hard error has occured; \n     *     otherwise it returns a zero.\n     */\n    error(fp: FatFsFile): number {\n        return this.#exports.f_error(this.#filePtr);\n    }\n\n}\n\n/**\n * FatFs Directory Reference\n */\nexport class FatFsDir {\n    #dirPtr: number;\n    #exports: FatFsExports;\n    #context: FatFsMemoryContext;\n\n    constructor(dirPtr: number, exports: FatFsExports, context: FatFsMemoryContext) {\n        this.#dirPtr = dirPtr;\n        this.#exports = exports;\n        this.#context = context;\n    }\n\n    get dp() {\n        return this.#dirPtr;\n    }\n\n    /**\n     * Closes the open directory.\n     */\n    close(): void {\n        throwIfError(\n            \"closing directory\",\n            () => this.#exports.f_closedir(this.#dirPtr)\n        );\n        this.#context.free(this.#dirPtr);\n    }\n\n    /**\n     * Reads an item of the directory.\n     * @returns Information about the next directory entry\n     */\n    read(): FatFsFileInfo {\n        return this.#context.enterScope(scope => {\n            const fno = scope.alloc(SIZE_FILINFO);\n            throwIfError(\n                \"reading directory\",\n                () => this.#exports.f_readdir(this.#dirPtr, fno)\n            );\n            const fnoData = this.#context.heap.subarray(fno, fno + SIZE_FILINFO);\n            return FatFsFileInfo.fromFilInfo(fnoData);\n        });\n    }\n\n    /**\n     * Rewinds the directory\n     */\n    rewind(): void {\n        throwIfError(\n            \"rewinding directory\",\n            () => this.#exports.f_readdir(this.#dirPtr, 0)\n        );\n    }\n\n    /**\n     * The f_findnext function searches for a next matched object\n     */\n    findNext(): FatFsFileInfo {\n        return this.#context.enterScope(scope => {\n            const fno = scope.alloc(SIZE_FILINFO);\n            throwIfError(\n                \"searching directory for next match\",\n                () => this.#exports.f_findnext(this.#dirPtr, fno)\n            );\n            const fnoData = this.#context.heap.subarray(fno, fno + SIZE_FILINFO);\n            return FatFsFileInfo.fromFilInfo(fnoData);\n        });\n    }\n\n    *[Symbol.iterator](): Iterator<FatFsFileInfo> {\n        let fileInfo: FatFsFileInfo;\n        this.rewind();\n        while ((fileInfo = this.read()).name !== '')\n            yield fileInfo;\n    }\n}\n\n/**\n * Options for creating a {@link FatFsDisk}.\n */\nexport type FatFsDiskOptions = {\n    /** The size of the filesystem disk sectors, in bytes. Uses 512 if not provided. */\n    sectorSize?: number; \n    /** Whether or not to enable multi-partition disks, which enables {@link FatFsDiskPartitionable.fdisk} */\n    multiPartition?: boolean; \n}\n\nconst FATFS_DISK_OPTION_DEFAULTS: Required<FatFsDiskOptions> = {\n    multiPartition: false,\n    sectorSize: DEFAULT_SECTOR_SIZE\n}\n\n/**\n * Represents a FAT filesystem over an array of bytes\n */\nexport class FatFsDisk {\n    #context: FatFsMemoryContext\n    #exports: FatFsExports;\n\n    /** \n     * @overload\n     * Create a new {@link FatFsDisk}.\n     * @param disk Array of bytes containing a FAT image (or anything if you would like to format)\n     * @param options Additional options. See {@link FatFsDiskOptions} for more information. Will return a {@link FatFsDiskPartitionable} if the `multiPartition` option is true.\n     */\n    static async create(disk: Uint8Array, options: FatFsDiskOptions & { multiPartition: true }): Promise<FatFsDiskPartitionable>;\n\n    /** \n     * @overload\n     * Create a new {@link FatFsDisk}.\n     * @param disk Array of bytes containing a FAT image (or anything if you would like to format)\n     * @param options Additional options. See {@link FatFsDiskOptions} for more information. Will return a {@link FatFsDiskPartitionable} if the `multiPartition` option is true.\n     */\n    static async create(disk: Uint8Array, options: FatFsDiskOptions): Promise<FatFsDisk>;\n\n    /** \n     * @overload\n     * Create a new {@link FatFsDisk} with defaults\n     * @param disk Array of bytes containing a FAT image (or anything if you would like to format)\n     */\n    static async create(disk: Uint8Array): Promise<FatFsDisk>;\n    static async create(disk: Uint8Array, options?: FatFsDiskOptions): Promise<FatFsDisk> {\n        const memory = new WebAssembly.Memory({ initial: 8 });\n        const validOptions = { ...FATFS_DISK_OPTION_DEFAULTS, ...(options ?? {}) };\n        const importObject = createImportObject(memory, disk, validOptions.sectorSize);\n        const source = await getWasm(importObject, validOptions);\n        const exports = source.instance.exports as FatFsExports;\n        const context = new FatFsMemoryContext(memory, exports);\n        return validOptions.multiPartition\n            ? new FatFsDiskPartitionable(context, exports)\n            : new FatFsDisk(context, exports);\n    }\n\n    /** \n     * Private constructor. Use {@link FatFsDisk.create} to create a {@link FatFsDisk} object. \n     */\n    constructor(\n        context: FatFsMemoryContext,\n        exports: FatFsExports,\n    ) {\n        this.#context = context;\n        this.#exports = exports;\n    }\n\n    /**\n     * The f_mkfs function creates an FAT/exFAT volume on the logical drive.\n     * @param opt Format options\n     * @returns OK or error code\n     */\n    mkfs(opt?: FatFsMkfsOptions | null): void {\n        this.#context.enterScope(scope => {\n            const pathPtr = scope.allocString(opt?.path ?? '');\n            let optPtr = 0;\n            if (typeof opt !== 'undefined' && opt !== null) {\n                optPtr = scope.alloc(16);\n                const view = this.#context.view;\n                view.setUint8(optPtr, opt?.fmt ?? 0);\n                view.setUint8(optPtr + 1, opt?.nFat ?? 0);\n                view.setUint32(optPtr + 2, opt?.align ?? 0, true);\n                view.setUint32(optPtr + 6, opt?.nRoot ?? 0, true);\n                view.setUint32(optPtr + 10, opt?.auSize ?? 0, true);\n            }\n            const workAreaPtr = scope.alloc(4096);\n            throwIfError(\n                \"formatting disk\",\n                () => this.#exports.f_mkfs(pathPtr, optPtr, workAreaPtr, 4096)\n            ) \n        });\n    }\n\n    /**\n     * The f_mount function gives work area to the FatFs module.\n     * @param path Pointer to the null-terminated string that specifies \n     *     the logical drive. The string without drive number means the \n     *     default drive.\n     * @param opt Mounting option. 0: Do not mount now (to be mounted \n     *     on the first access to the volume), 1: Force mounted the \n     *     volume to check if it is ready to work.\n     * @returns reference to the mounted work area\n     */\n    mount(path?: string, opt?: number): FatFsObject {\n        const malloc = (size: number) => this.#context.alloc(size);\n        return this.#context.enterScope(scope => {\n            const fsPtr = malloc(SIZE_FATFS_OBJ);\n            for (let i = 0; i < SIZE_FATFS_OBJ; i++)\n                this.#context.heap[fsPtr + i] = 0;\n            const pathPtr = scope.allocString(path ?? '');\n            throwIfError(\n                \"mounting workspace\",\n                () => this.#exports.f_mount(fsPtr, pathPtr, opt ?? 0),\n                () => this.#context.free(fsPtr)\n            );\n            return new FatFsObject(fsPtr, this.#context);\n        });\n    }\n\n    /**\n     * Unregisters the filesystem object\n     * @param path Pointer to the null-terminated string that specifies \n     *     the logical drive. The string without drive number means the \n     *     default drive.\n     */\n    unmount(path?: string): void {\n        return this.#context.enterScope(scope => {\n            //const [, fs] = this.getFree(path ?? '');\n            try {\n                const pathPtr = scope.allocString(path ?? '');\n                throwIfError(\n                    \"unmounting workspace\",\n                    () => this.#exports.f_mount(0, pathPtr, 0)\n                );\n            } finally {\n                //this.#context.free(fs.ptr);\n            }\n        });\n    }\n\n    /**\n     * The f_open function opens a file.\n     * @param path Pointer to the null-terminated string that specifies the \n     *     file name to open or create.\n     * @param mode Mode flags that specifies the type of access and open \n     *     method for the file. It is specified by a combination of following \n     *     flags.\n     * @returns File object\n     */\n    open(path: string, mode: FatFsMode): FatFsFile {\n        return this.#context.enterScope(scope => {\n            const pathPtr = scope.allocString(path);\n            const fpPtr = this.#context.alloc(576);\n            throwIfError(\n                \"opening file\",\n                () => this.#exports.f_open(fpPtr, pathPtr, mode),\n                () => this.#context.free(fpPtr)\n            );\n            return new FatFsFile(fpPtr, this.#exports, this.#context);\n        });\n    }\n\n    /**\n     * Mounts the filesystem, executes a user function, and unmounts\n     * @param action The action to perform\n     * @param path The logical drive. An empty string without drive number \n     *     means the default drive.\n     */\n    session<T extends () => any>(action: T, path: string = ''): ReturnType<T> {\n        this.mount(path);\n        try {\n            return action();\n        } finally {\n            this.unmount(path);\n        }\n    }\n\n    /**\n     * Read an entire file.\n     * @param path Path to the file to read\n     * @returns The contents of the file\n     */\n    readFile(path: string): Uint8Array {\n        const info = this.stat(path);\n        const result = new Uint8Array(info.size);\n        const file = this.open(path, FatFsMode.READ);\n        try {\n            file.read(result);\n            return result;\n        } finally {\n            file.close();\n        }\n    }\n\n    /**\n     * Write an entire file.\n     * @param path Path to the file to write\n     * @param contents Contents to write to the file\n     */\n    writeFile(path: string, contents: Uint8Array): void {\n        const file = this.open(path, FatFsMode.WRITE | FatFsMode.OPEN_ALWAYS);\n        try {\n            file.write(contents);\n        } finally {\n            file.close();\n        }\n    }\n\n    /**\n     * The f_opendir function opens a directory.\n     * @param path Pointer to the null-terminated string that specifies the \n     *     directory name to be opened.\n     * @returns Directory object\n     */\n    openDir(path: string): FatFsDir {\n        return this.#context.enterScope(scope => {\n            const pathPtr = scope.allocString(path);\n            const dpPtr = this.#context.alloc(SIZE_DIR);\n            throwIfError(\n                \"opening directory\",\n                () => this.#exports.f_opendir(dpPtr, pathPtr),\n                () => this.#context.free(dpPtr)\n            );\n            return new FatFsDir(dpPtr, this.#exports, this.#context);\n        });\n    }\n    \n    /**\n     * Searches a directory for an item.\n     * @param path The directory name to be opened.\n     * @param pattern The pattern to search for \n     * @returns The directory, and the first matching entry\n     */\n    findFirst(path: string, pattern: string): [FatFsDir, FatFsFileInfo] {\n        return this.#context.enterScope(scope => {\n            const pathPtr = scope.allocString(path);\n            const patternPtr = scope.allocString(pattern);\n            const fno = scope.alloc(SIZE_FILINFO);\n            const dpPtr = this.#context.alloc(SIZE_DIR);\n            throwIfError(\n                \"searching directory\",\n                () => this.#exports.f_findfirst(dpPtr, fno, pathPtr, patternPtr),\n            );\n            const fnoData = this.#context.heap.subarray(fno, fno + SIZE_FILINFO);\n            return [\n                new FatFsDir(dpPtr, this.#exports, this.#context),\n                FatFsFileInfo.fromFilInfo(fnoData)\n            ];\n        });\n    }\n\n    /**\n     * Searches a directory\n     * \n     * @param path The directory name to be opened.\n     * @param pattern The pattern to search for \n     * @returns An iterator to the search results\n     */\n    *find(path: string, pattern: string): IterableIterator<FatFsFileInfo> {\n        let dir: FatFsDir;\n        let fileInfo: FatFsFileInfo;\n        [dir, fileInfo] = this.findFirst(path, pattern);\n        while (fileInfo.name !== '') {\n            yield fileInfo;\n            fileInfo = dir.findNext();\n        }\n    }\n\n    /**\n     * The f_stat function checks the existence of a file or sub-directory.\n     * @param path Pointer to the null-terminated string that specifies the \n     *     object to get its information. The object must not be the root \n     *     direcotry.\n     * @returns OK or error code\n     */\n    stat(path: string): FatFsFileInfo {\n        return this.#context.enterScope(scope => {\n            const pathPtr = scope.allocString(path);\n            const fno = scope.alloc(SIZE_FILINFO);\n            throwIfError(\n                \"getting file information\",\n                () => this.#exports.f_stat(pathPtr, fno)\n            );\n            const fnoData = this.#context.heap.subarray(fno, fno + SIZE_FILINFO);\n            return FatFsFileInfo.fromFilInfo(fnoData);\n        });\n    }\n\n    /**\n     * The f_unlink function removes a file or sub-directory from the volume.\n     * @param path Pointer to a null-terminated string that specifies the file \n     *     or sub-directory to be removed.\n     */\n    unlink(path: string): void {\n        this.#context.enterScope(scope => {\n            const pathPtr = scope.allocString(path);\n            throwIfError(\n                \"deleting file or directory\",\n                () => this.#exports.f_unlink(pathPtr)\n            );\n        });\n    }\n\n    /**\n     * The f_rename function renames and/or moves a file or sub-directory.\n     * @param oldName Pointer to a null-terminated string that specifies the \n     *     existing file or sub-directory to be renamed.\n     * @param newName Pointer to a null-terminated string that specifies the \n     *     new object name. A drive number may be specified in this string but \n     *     it is ignored and assumed as the same drive of the old_name. Any \n     *     object with this path name except old_name must not be exist, or the \n     *     function fails with FR_EXIST.\n     * @returns OK or error code\n     */\n    rename(oldName: string, newName: string): void {\n        this.#context.enterScope(scope => {\n            const oldNamePtr = scope.allocString(oldName);\n            const newNamePtr = scope.allocString(newName);\n            throwIfError(\n                \"renaming file or directory\",\n                () => this.#exports.f_rename(oldNamePtr, newNamePtr)\n            );\n        });\n    }\n\n    /**\n     * The f_chmod function changes the attribute of a file or sub-directory.\n     * @param path Pointer to the null-terminated string that specifies an \n     *     object to be changed\n     * @param attr Attribute flags to be set in one or more combination. The \n     *     specified flags are set and others are cleared.\n     * @param mask Attribute mask that specifies which attribute is changed. \n     *     The specified attributes are set or cleared and others are left \n     *     unchanged.\n     * @returns OK or error code\n     */\n    chmod(path: string, attr: number, mask: number): void {\n        this.#context.enterScope(scope => {\n            const pathPtr = scope.allocString(path);\n            throwIfError(\n                \"changing file or directory permissions\",\n                () => this.#exports.f_chmod(pathPtr, attr, mask)\n            );\n        });\n    }\n\n    /**\n     * The f_utime function changes the timestamp of a file or sub-directory.\n     * @param path Pointer to the null-terminated string that specifies an \n     *     object to be changed.\n     * @param time Pointer to the file information structure that has a \n     *     timestamp to be set in member fdate and ftime. Do not care any \n     *     other members.\n     * @returns OK or error code\n     */\n    utime(path: string, time: Date): void {\n        this.#context.enterScope(scope => {\n            const pathPtr = scope.allocString(path);\n            const fno = scope.alloc(24);\n\n            // set date and time only, doesn't care about other entries\n            const year = (time.getFullYear() - 1980) & 0x7F;\n            const month = time.getMonth() + 1;\n            const day = time.getDay();\n            const encodedDate = (year << 9) | (month << 5) | day;\n            this.#context.view.setUint16(fno + 4, encodedDate, true);\n    \n            const hour = time.getHours()\n            const minute = time.getMinutes();\n            const seconds = time.getSeconds() >>> 1;\n            const encodedTime = (hour << 11) | (minute << 5) | seconds;\n            this.#context.view.setUint16(fno + 6, encodedTime, true);\n        \n            throwIfError(\n                \"changing timestamp of file or directory\",\n                () => this.#exports.f_utime(pathPtr, fno)\n            );\n        });\n    }\n\n    /**\n     * The f_mkdir function creates a new directory.\n     * @param path Pointer to the null-terminated string that specifies the \n     *     directory name to create.\n     */\n    mkdir(path: string): void {\n        const f_mkdir = this.#exports.f_mkdir as (path: number) => number;\n        this.#context.enterScope(scope => {\n            const pathPtr = scope.allocString(path);\n            throwIfError(\n                \"creating directory\",\n                () => this.#exports.f_mkdir(pathPtr)\n            );\n        });\n    }\n\n    /**\n     * The f_chdir function changes the current directory of the logical drive.\n     * @param path Pointer to the null-terminated string that specifies the \n     *     directory to be set as current directory.\n     */\n    chdir(path: string): void {\n        this.#context.enterScope(scope => {\n            const pathPtr = scope.allocString(path);\n            throwIfError(\n                \"changing current directory\",\n                () => this.#exports.f_chdir(pathPtr)\n            );\n        });\n    }\n\n    /**\n     * The f_chdrive function changes the current drive.\n     * @param path Specifies the logical drive number to be set as the current \n     *     drive.\n     */\n    chdrive(path: string): void {\n        this.#context.enterScope(scope => {\n            const pathPtr = scope.allocString(path);\n            throwIfError(\n                \"changing current drive\",\n                () => this.#exports.f_chdrive(pathPtr)\n            );\n        });\n    }\n\n    /**\n     * The f_getcwd function retrieves the current directory of the current \n     * drive.\n     * @returns The current directory.\n     */\n    getcwd(): string {\n        return this.#context.enterScope(scope => {\n            const buffer = scope.alloc(260);\n            throwIfError(\n                \"getting current directory\",\n                () => this.#exports.f_getcwd(buffer, 260)\n            );\n            return this.#context.decodeString(buffer, 260);\n        });\n    }\n\n    /**\n     * \n     * @param path Pointer to the null-terminated string that specifies the \n     *     logical drive. A null-string means the default drive.\n     * @returns tuple with the number of free clusters, and a FATFS \n     *     object containing number of sectors per cluster.\n     */\n    getFree(path?: string | null): [number, FatFsObject] {\n        return this.#context.enterScope(scope => {\n            const pathPtr = scope.allocString(path ?? '');\n            const nclst = scope.alloc(4);\n            const fatfsPtr = scope.alloc(4);\n            throwIfError(\n                \"getting free space on drive\",\n                () => this.#exports.f_getfree(pathPtr, nclst, fatfsPtr),\n            );\n            return [\n                this.#context.view.getUint32(nclst, true), \n                new FatFsObject(fatfsPtr, this.#context)\n            ];\n        });\n    }\n\n    /**\n     * The f_getlabel function returns volume label and volume serial number \n     * of a volume.\n     * @param path Pointer to the null-terminated string that specifies the \n     *     logical drive. Null-string specifies the default drive.\n     * @returns tuple containing the result, the volume label, and the volume \n     *     serial number\n     */\n    getLabel(path?: string): [string, number] {\n        return this.#context.enterScope(scope => {\n            const pathPtr = scope.allocString(path ?? '');\n            const label = scope.alloc(13);\n            this.#context.heap[label + 12] = 0;\n            const vsn = scope.alloc(4);\n            throwIfError(\n                \"getting volume label\",\n                () => this.#exports.f_getlabel(pathPtr, label, vsn)\n            );\n            return [\n                this.#context.decodeString(label, 13),\n                this.#context.view.getUint32(vsn, true)\n            ];\n        });\n    }\n\n    /**\n     * The f_setlabel function sets/removes the label of a volume.\n     * @param label Pointer to the null-terminated string that specifies the \n     *     volume label to be set.\n     */\n    setLabel(label: string): void {\n        this.#context.enterScope(scope => {\n            const labelPtr = scope.allocString(label);\n            throwIfError(\n                \"setting volume label\",\n                () => this.#exports.f_setlabel(labelPtr)\n            );\n        });\n    }\n\n    /**\n     * The f_setcp function sets the active code page.\n     * @param cp OEM code page to be used for the path name.\n     */\n    setCP(cp: number): void {\n        const f_setcp = this.#exports.f_setcp as (cp: number) => number;\n        throwIfError(\n            \"setting active code page\",\n            () => f_setcp(cp)\n        );\n    }\n}\n\n/**\n * Extension of {@link FatFsDisk} with extensions for partitioning a FAT drive with up to 4 partitions.\n * \n * If multi-partition support is enabled, accessing some types of FAT disks (e.g. floppes) may not work correctly.\n */\nexport class FatFsDiskPartitionable extends FatFsDisk {\n    #context: FatFsMemoryContext;\n    #exports: FatFsExports;\n\n    /**\n     * Private constructor. Use {@link FatFsDisk.create} with the `multiPartition` option set to true to create a {@link FatFsDiskPartitionable}. \n     */\n    constructor(\n        context: FatFsMemoryContext,\n        exports: FatFsExports,\n    ) {\n        super(context, exports);\n        this.#context = context;\n        this.#exports = exports;\n    }\n\n    /**\n     * The f_fdisk function divides a physical drive.\n     * @param ptbl List of partition size to create on the drive.\n     * @param pdrv Specifies the physical drive to be divided. This is not the \n     *     logical drive number but the drive identifier passed to the low \n     *     level disk functions.\n     */\n    fdisk(ptbl: number[], pdrv?: number): void {\n        this.#context.enterScope(scope => {\n            const workAreaPtr = scope.alloc(FF_MAX_SS);\n            const ptblPtr = scope.alloc(ptbl.length * 4);\n            for (let i = 0; i < ptbl.length; i++)\n                this.#context.view.setUint32(ptblPtr + (i * 4), ptbl[i]);\n            throwIfError(\n                \"partitioning disk\",\n                () => this.#exports.f_fdisk(pdrv ?? 0, ptblPtr, workAreaPtr)\n            );\n        });\n    }\n}\n"],
  "mappings": ";;;;;;;;IAQYA;IASAC;IASAC;IAwBAC;IASAC;AAAAA,CAnDZ,SAAYJ,IAAAA;AACRA,EAAAA,GAAAA,GAAA,YAAA,CAAA,IAAA,aACAA,GAAAA,GAAA,mBAAA,CAAA,IAAA,oBACAA,GAAAA,GAAA,kBAAA,CAAA,IAAA,mBACAA,GAAAA,GAAA,iBAAA,CAAA,IAAA,kBACAA,GAAAA,GAAA,YAAA,CAAA,IAAA;AACH,EANWA,MAAAA,IAMX,CAAA,EAAA,GAGD,SAAYC,IAAAA;AACRA,EAAAA,GAAAA,GAAA,MAAA,CAAA,IAAA,OACAA,GAAAA,GAAA,QAAA,CAAA,IAAA,SACAA,GAAAA,GAAA,QAAA,CAAA,IAAA,SACAA,GAAAA,GAAA,MAAA,CAAA,IAAA,OACAA,GAAAA,GAAA,MAAA,CAAA,IAAA;AACH,EANWA,MAAAA,IAMX,CAAA,EAAA,GAGD,SAAYC,IAAAA;AACRA,EAAAA,GAAAA,GAAA,KAAA,CAAA,IAAA,MACAA,GAAAA,GAAA,WAAA,CAAA,IAAA,YACAA,GAAAA,GAAA,UAAA,CAAA,IAAA,WACAA,GAAAA,GAAA,YAAA,CAAA,IAAA,aACAA,GAAAA,GAAA,UAAA,CAAA,IAAA,WACAA,GAAAA,GAAA,UAAA,CAAA,IAAA,WACAA,GAAAA,GAAA,eAAA,CAAA,IAAA,gBACAA,GAAAA,GAAA,SAAA,CAAA,IAAA,UACAA,GAAAA,GAAA,QAAA,CAAA,IAAA,SACAA,GAAAA,GAAA,iBAAA,CAAA,IAAA,kBACAA,GAAAA,GAAA,kBAAA,EAAA,IAAA,mBACAA,GAAAA,GAAA,gBAAA,EAAA,IAAA,iBACAA,GAAAA,GAAA,cAAA,EAAA,IAAA,eACAA,GAAAA,GAAA,gBAAA,EAAA,IAAA,iBACAA,GAAAA,GAAA,eAAA,EAAA,IAAA,gBACAA,GAAAA,GAAA,UAAA,EAAA,IAAA,WACAA,GAAAA,GAAA,SAAA,EAAA,IAAA,UACAA,GAAAA,GAAA,kBAAA,EAAA,IAAA,mBACAA,GAAAA,GAAA,sBAAA,EAAA,IAAA,uBACAA,GAAsBA,GAAA,oBAAA,EAAA,IAAA;AACzB,EArBWA,MAAAA,IAqBX,CAAA,EAAA,GAGD,SAAYC,IAAAA;AACRA,EAAAA,GAAAA,GAAA,MAAA,CAAA,IAAA,OACAA,GAAAA,GAAA,MAAA,CAAA,IAAA,OACAA,GAAAA,GAAA,MAAA,CAAA,IAAA,OACAA,GAAAA,GAAA,MAAA,EAAA,IAAA,OACAA,GAAAA,GAAA,MAAA,EAAA,IAAA;AACH,EANWA,MAAAA,IAMX,CAAA,EAAA,GAGD,SAAYC,IAAAA;AAIRA,EAAAA,GAAAA,GAAA,OAAA,CAAA,IAAA,QAKAA,GAAAA,GAAA,QAAA,CAAA,IAAA,SAIAA,GAAAA,GAAA,gBAAA,CAAA,IAAA,iBAKAA,GAAAA,GAAA,aAAA,CAAA,IAAA,cAKAA,GAAAA,GAAA,gBAAA,CAAA,IAAA,iBAIAA,GAAAA,GAAA,cAAA,EAAA,IAAA,eAKAA,GAAAA,GAAA,cAAA,EAAA,IAAA;AACH,EAjCWA,MAAAA,IAiCX,CAAA,EAAA;AAED,IAEMC,IAAe;AAFrB,IAYMC,IAAgB,IAAIC,IAAI,IAAAA,IAAA,iCAAA,YAAAC,GAAAA,EAAAC,MAAAA,YAA+BD,GAAAA;AAZ7D,IAaME,IAAe,IAAIH,IAAI,IAAAA,IAAA,kCAAA,YAAAC,GAAAA,EAAAC,MAAAA,YAAgCD,GAAAA;AAa7D,SAASG,EAAaC,IAAoBC,IAA2BC,IAAAA;AACjE,QAAMC,KAASF,GAAAA;AACf,MAAIE,OAAWb,EAAYc,GAEvB,OADAF,MAAAA,gBAAAA,MACM,IAAIG,EAAWL,IAAYG,EAAAA;AAEzC;;AA8IA,IAAMG,IAAN,MAAMA;EAGF,YAAYC,IAAkBC,IAAAA;AAF9BD;AACAC;AAEIC,uBAAAA,IAAiBF,KACjBE,mBAAAA,IAAgBD;EAAAA;EAGpB,IAAA,MAAIE;AACA,WAAOD,mBAAAA;EAAKF;EAMhB,IAAA,QAAII;AACA,WAAOF,mBAAAA,IAAcG,KAAKC,UAAUJ,mBAAAA,MAxLjB,IAAA,IAwLsD;EAAA;AAAA;AAf7EF;AACAC;;AAkBJ,IAAMM,IAAN,MAAMA;EAIF,YAAYC,IAA4BC,IAAAA;AAHxCD;AACAC;AAGIP,uBAAAA,IAAeM,KACfN,mBAAAA,IAAgBO;EAAAA;EAGpB,IAAA,OAAIC;AACA,WAAO,IAAIC,WAAWT,mBAAAA,IAAaU,MAAAA;EAAAA;EAGvC,IAAA,OAAIP;AACA,WAAO,IAAIQ,SAASX,mBAAAA,IAAaU,MAAAA;EAAAA;EAGrC,YAAYE,IAAAA;AACR,QAAI,QAAOA,GACP,QAAO;AACX,UAAMC,KAAY,IAAIC,cAAcC,OAAOH,EAAAA,GACrCI,KAAUhB,KAAKiB,MAAMJ,GAAUK,SAAS,CAAA,GACxCC,KAAYnB,KAAKQ,KAAKY,SAASJ,IAASA,KAAUH,GAAUK,SAAS,CAAA;AAG3E,WAFAC,GAAUE,IAAIR,EAAAA,GACdM,GAAUA,GAAUD,SAAS,CAAA,IAAK,GAC3BF;EAAAA;EAGX,MAAMM,IAAAA;AACF,WAAOtB,mBAAAA,IAAcuB,OAAOD,EAAAA;EAAAA;EAGhC,KAAKrB,IAAAA;AACDD,uBAAAA,IAAcwB,KAAKvB,EAAAA;EAAAA;EAGvB,aAAaS,IAAgBY,IAAAA;AACzB,UAAMG,KAAWzB,KAAKQ,KAAKY,SAASV,IAAQA,KAASY,EAAAA,GAC/CI,KAAYD,GAASE,QAAQ,CAAA,GAC7BC,KAAaF,MAAa,IAC1BD,GAASL,SAAS,GAAGM,EAAAA,IACrBD;AACN,WAAO,IAAII,cAAcC,OAAOF,EAAAA;EAAAA;EAGpC,WAAcG,IAAAA;AACV,UAAMC,KAAsB,CAAA,GACtBC,KAAQ,EACVhB,OAAQK,CAAAA,OAAAA;AACJ,YAAMrB,KAAMD,KAAKiB,MAAMK,EAAAA;AAEvB,aADAU,GAAUE,QAAQjC,EAAAA,GACXA;IAAG,GAEdkC,aAAcvB,CAAAA,OAAAA;AACV,YAAMX,KAAMD,KAAKmC,YAAYvB,EAAAA;AAE7B,aADAoB,GAAUE,QAAQjC,EAAAA,GACXA;IAAG,EAAA;AAGlB,QAAA;AACI,aAAO8B,GAASE,EAAAA;IAAAA,UACV;AACN,iBAAWhC,MAAO+B,GACdhC,MAAKwB,KAAKvB,EAAAA;IAAAA;EAAAA;AAAAA;AA9DtBK;AACAC;AA6DsBN,IASbmC,IATanC,MASbmC,GAAAA;EAUT,YAAYd,IAAce,IAAYC,IAAgBC,IAAAA;AAR7CjB;AAEAe;AAEAC;AAEAC;AAGLvC,SAAKsB,OAAOA,IACZtB,KAAKqC,OAAOA,IACZrC,KAAKsC,SAASA,IACdtC,KAAKuC,OAAOA;EAAAA;EAOhB,OAAA,YAAmBC,IAAAA;AACf,UAAMrC,KAAO,IAAIQ,SAAS6B,GAAK9B,QAAQ8B,GAAKC,YAAYD,GAAKE,UAAAA,GACvDpB,KAAOnB,GAAKwC,UAAU,GAAA,IAAG,GAEzBC,KAAczC,GAAKC,UAAU,GAAA,IAAG,GAChCyC,KAAO,SAAuB,QAAdD,OAAyB,IACzCE,OAAwB,MAAdF,OAAyB,KAAK,GACxCG,KAAoB,KAAdH,IACNI,KAAc7C,GAAKC,UAAU,GAAA,IAAG,GAIhCiC,KAAO,IAAIY,KAAKJ,IAAMC,IAAOC,KAHP,QAAdC,OAAyB,KACT,OAAdA,OAAyB,GACD,KAAV,KAAdA,GAAAA,GAGVV,KAASE,GAAK,CAAA,GAEdU,KAAYV,GAAKpB,SAAS,GAAG,EAAA,GAC7BM,KAAYwB,GAAUvB,QAAQ,CAAA,GAC9BwB,KAAczB,MAAa,IAC3BwB,GAAU9B,SAAS,GAAGM,EAAAA,IACtBwB,IACAX,KAAO,IAAIV,cAAcC,OAAOqB,EAAAA;AAEtC,WAAO,IAAIf,GAAcd,IAAMe,IAAMC,IAAQC,EAAAA;EAAAA;EAMjD,IAAA,aAAIa;AAAwB,WAAA,CAAA,EAAUpD,KAAKsC,SAASxD,EAAYuE;EAAK;EAKrE,IAAA,cAAIC;AAAyB,WAAA,CAAA,EAAUtD,KAAKsC,SAASxD,EAAYyE;EAAK;EAKtE,IAAA,WAAIC;AAAsB,WAAA,CAAA,EAAUxD,KAAKsC,SAASxD,EAAY2E;EAAK;EAKnE,IAAA,YAAIC;AAAuB,WAAA,CAAA,EAAU1D,KAAKsC,SAASxD,EAAY6E;EAAK;EAKpE,IAAA,WAAIC;AAAsB,WAAA,CAAA,EAAU5D,KAAKsC,SAASxD,EAAY+E;EAAK;AAAA;AAIjE,IAAOjE,IAAP,MAAOA,WAAmBkE,MAAAA;EAE5B,YAAYtE,IAAgBuE,IAAAA;AAExBC,UADgB,SAASxE,EAAAA,KAAWX,EAAYkF,EAAAA,CAAAA,KAAeA,EAAAA,GAAAA;AAFnErE;AAIIuE,WAAOC,eAAelE,MAAMJ,GAAWuE,SAAAA,GACvCnE,KAAKN,SAASqE;EAAAA;AAAAA;;AAAAA,IAOTK,IAPSL,MAOTK;EAKT,YACIC,IACA9D,IACAR,IAAAA;AAPJsE;AACA9D,uBAAAA;AACAR,uBAAAA;AAOIC,uBAAAA,IAAgBqE,KAChBrE,mBAAAA,KAAgBO,KAChBP,mBAAAA,KAAgBD;EAAAA;EAMpB,IAAA,KAAIuE;AACA,WAAOtE,mBAAAA;EAAKqE;EAShB,KAAKE,IAAkBC,IAAAA;AACnB,UAAMC,KAASzE,mBAAAA,KAAcyE,QACvBJ,KAAUrE,mBAAAA,KACV0E,KAAcF,MAAOD,GAAKrD;AAChC,WAAOlB,mBAAAA,KAAc2E,WAAY1C,CAAAA,OAAAA;AAC7B,YAAM2C,KAAU3C,GAAMhB,MAAMyD,EAAAA,GACtBG,KAAQ5C,GAAMhB,MAAM,CAAA;AAC1B3B,QACI,gBACA,MAAMmF,GAAOJ,IAASO,IAASF,IAAaG,EAAAA,CAAAA;AAEhD,YAAMC,KAAY9E,mBAAAA,KAAcG,KAAKwC,UAAUkC,IAAAA,IAAO;AAEtD,aADAN,GAAKlD,IAAIrB,mBAAAA,KAAcQ,KAAKY,SAASwD,IAASA,KAAUE,EAAAA,CAAAA,GACjDA;IAAS,CAAA;EAAA;EAYxB,MAAMP,IAAkBQ,IAAAA;AACpB,WAAO/E,mBAAAA,KAAc2E,WAAW1C,CAAAA,OAAAA;AAC5B,YAAM+C,KAAeD,MAAOR,GAAKrD,QAC3B0D,KAAU3C,GAAMhB,MAAM+D,EAAAA,GACtBC,KAAQhD,GAAMhB,MAAM,CAAA;AAM1B,aALAjB,mBAAAA,KAAcQ,KAAKY,SAASwD,IAASA,KAAUI,EAAAA,EAAc3D,IAAIkD,EAAAA,GACjEjF,EACI,gBACA,MAAMU,mBAAAA,KAAckF,QAAQlF,mBAAAA,KAAe4E,IAASI,IAAcC,EAAAA,CAAAA,GAE/DjF,mBAAAA,KAAcG,KAAKwC,UAAUsC,IAAAA,IAAO;IAAK,CAAA;EAAA;EAOxD,QAAAE;AACI,QAAA;AACI7F,QACI,gBACA,MAAMU,mBAAAA,KAAcoF,QAAQpF,mBAAAA,GAAKqE,CAAAA;IAAAA,UAE/B;AACNrE,yBAAAA,KAAcwB,KAAKxB,mBAAAA,GAAKqE;IAAAA;EAAAA;EAOhC,OAAAgB;AACI/F,MACI,gBACA,MAAMU,mBAAAA,KAAcsF,OAAOtF,mBAAAA,GAAKqE,CAAAA;EAAAA;EAYxC,MAAMkB,IAAAA;AACFjG,MACI,WACA,MAAMU,mBAAAA,KAAcwF,QAAQxF,mBAAAA,KAAeuF,EAAAA,CAAAA;EAAAA;EAInD,SAAAE;AACIzF,SAAK0F,MAAM,CAAA;EAAA;EAOf,WAAAC;AACIrG,MACI,mBACA,MAAMU,mBAAAA,KAAc4F,WAAW5F,mBAAAA,GAAKqE,CAAAA;EAAAA;EAY5C,OAAOwB,IAAaC,IAAAA;AAChBxG,MACI,kBACA,MAAMU,mBAAAA,KAAc+F,SAAS/F,mBAAAA,KAAe6F,IAAKC,EAAAA,CAAAA;EAAAA;EAQzD,KAAKE,IAAAA;AACD,WAAOhG,mBAAAA,KAAc2E,WAAW1C,CAAAA,OAAAA;AAC5B,YAAM2C,KAAU3C,GAAMhB,MAAM+E,KAAU,CAAA;AAKtC,aAJA1G,EACI,4BACA,MAAMU,mBAAAA,KAAciG,OAAOrB,IAASoB,IAAShG,mBAAAA,GAAKqE,CAAAA,GAE/CrE,mBAAAA,KAAckG,aAAatB,IAASoB,KAAU,CAAA;IAAE,CAAA;EAAA;EAW/D,KAAKG,IAAAA;AACD,UAAMC,KAAUD,KAAM;AACtB,WAAOnG,mBAAAA,KAAcqG,OAAOD,IAASpG,mBAAAA,GAAKqE;EAAAA;EAY9C,KAAKiC,IAAAA;AACD,UAAMC,KAASvG,mBAAAA,KAAcuG;AAC7B,WAAOvG,mBAAAA,KAAc2E,WAAW1C,CAAAA,OAAAA;AAC5B,YAAMuE,KAASvE,GAAME,YAAYmE,EAAAA;AACjC,aAAOC,GAAOC,IAAQxG,mBAAAA,GAAKqE;IAAS,CAAA;EAAA;EAQ5C,OAAAoC;AACI,WAAOzG,mBAAAA,KAAc0G,OAAO1G,mBAAAA,GAAKqE;EAAAA;EASrC,IAAIC,IAAAA;AACA,WAAOtE,mBAAAA,KAAc2G,MAAM3G,mBAAAA,GAAKqE;EAAAA;EAOpC,OAAA/C;AACI,WAAOtB,mBAAAA,KAAc4G,OAAO5G,mBAAAA,GAAKqE;EAAAA;EAQrC,MAAMC,IAAAA;AACF,WAAOtE,mBAAAA,KAAc6G,QAAQ7G,mBAAAA,GAAKqE;EAAAA;AAAAA;AAnNtCA;AACA9D,MAAAA;AACAR,MAAAA;;AAiNsCsE,IAQ7ByC,IAR6BzC,MAQ7ByC;EAKT,YAAYC,IAAgBxG,IAAuBR,IAAAA;AAJnDgH;AACAxG,uBAAAA;AACAR,uBAAAA;AAGIC,uBAAAA,IAAe+G,KACf/G,mBAAAA,KAAgBO,KAChBP,mBAAAA,KAAgBD;EAAAA;EAGpB,IAAA,KAAIiH;AACA,WAAOhH,mBAAAA;EAAK+G;EAMhB,QAAA5B;AACI7F,MACI,qBACA,MAAMU,mBAAAA,KAAciH,WAAWjH,mBAAAA,GAAK+G,CAAAA,GAExC/G,mBAAAA,KAAcwB,KAAKxB,mBAAAA,GAAK+G;EAAAA;EAO5B,OAAAG;AACI,WAAOlH,mBAAAA,KAAc2E,WAAW1C,CAAAA,OAAAA;AAC5B,YAAMkF,KAAMlF,GAAMhB,MAAMjC,CAAAA;AACxBM,QACI,qBACA,MAAMU,mBAAAA,KAAcoH,UAAUpH,mBAAAA,KAAcmH,EAAAA,CAAAA;AAEhD,YAAME,KAAUrH,mBAAAA,KAAcQ,KAAKY,SAAS+F,IAAKA,KAAMnI,CAAAA;AACvD,aAAOoD,EAAckF,YAAYD,EAAAA;IAAQ,CAAA;EAAA;EAOjD,SAAA5B;AACInG,MACI,uBACA,MAAMU,mBAAAA,KAAcoH,UAAUpH,mBAAAA,KAAc,CAAA,CAAA;EAAA;EAOpD,WAAAuH;AACI,WAAOvH,mBAAAA,KAAc2E,WAAW1C,CAAAA,OAAAA;AAC5B,YAAMkF,KAAMlF,GAAMhB,MAAMjC,CAAAA;AACxBM,QACI,sCACA,MAAMU,mBAAAA,KAAcwH,WAAWxH,mBAAAA,KAAcmH,EAAAA,CAAAA;AAEjD,YAAME,KAAUrH,mBAAAA,KAAcQ,KAAKY,SAAS+F,IAAKA,KAAMnI,CAAAA;AACvD,aAAOoD,EAAckF,YAAYD,EAAAA;IAAQ,CAAA;EAAA;EAIjD,EAAEI,OAAOC,QAAAA,IAAAA;AACL,QAAIC;AAEJ,SADA3H,KAAKyF,OAAAA,GACoC,QAAjCkC,KAAW3H,KAAKkH,KAAAA,GAAQ3E,OAAAA,OACtBoF;EAAAA;AAAAA;AAtEdZ;AACAxG,MAAAA;AACAR,MAAAA;AAkFJ,IAAM6H,IAAyD,EAC3DC,gBAAAA,OACAC,YAnpBwB,IAAA;;AAAA,IAypBfC,KAzpBe,MAypBfA,GAAAA;EAyCT,YACIhI,IACAQ,IAAAA;AA1CJR,uBAAAA;AACAQ,uBAAAA;AA2CIP,uBAAAA,KAAgBD,KAChBC,mBAAAA,KAAgBO;EAAAA;EApBpB,aAAA,OAAoByH,IAAkBC,IAAAA;AAClC,UAAM3H,KAAS,IAAI4H,YAAYC,OAAO,EAAEC,SAAS,EAAA,CAAA,GAC3CC,KAAe,EAAA,GAAKT,GAAAA,GAAgCK,MAAW,CAAE,EAAA,GACjEK,KArpBd,SACIhI,IACA0H,IACAF,IAAAA;AAEA,YAAMS,KAA2C,KAArCT,MAtCY,MAuClBU,KAAeR,GAAKtF,aAAa6F,KAAM;AAE7C,aAAO,EACHE,KAAK,EACDnI,QAAQA,IACRoI,iBAAkBC,CAAAA,OACP9J,EAAYc,IAEvBiJ,aAAcD,CAAAA,OACH9J,EAAYc,IAEvBkJ,WAAW,CAACF,IAAcpE,IAAcuE,IAAgBC,OAAAA;AACpD,cAAMC,KAAMhB,GAAK5G,SAAS0H,KAASP,KAAKO,KAASC,MAASR,EAAAA;AAG1D,eAFa,IAAI9H,WAAWH,GAAOI,MAAAA,EAC9BW,IAAI2H,IAAKzE,EAAAA,GACP1F,EAAYc;MAAE,GAEzBsJ,YAAY,CAACN,IAAcpE,IAAcuE,IAAgBC,OAAAA;AACrD,cACMC,KADO,IAAIvI,WAAWH,GAAOI,MAAAA,EAClBU,SAASmD,IAAMA,KAAQwE,KAAQR,EAAAA;AAEhD,eADAP,GAAK3G,IAAI2H,IAAKF,KAASP,EAAAA,GAChB1J,EAAYc;MAAE,GAEzBuJ,YAAY,CAACP,IAAcQ,IAAa5E,OAAAA;AACpC,cAAMpE,KAAO,IAAIQ,SAASL,GAAOI,MAAAA;AACjC,gBAAQyI,IAAAA;UACJ,KAAKxK,EAAWyK;AAGZ;UACJ,KAAKzK,EAAW0K;AACZlJ,YAAAA,GAAKmJ,UAAU/E,IAAMgE,IAAAA,IAAI;AACzB;UACJ,KAAK5J,EAAW4K;AACZpJ,YAAAA,GAAKqJ,UAAUjF,IAAMiE,IAAAA,IAAa;AAClC;UACJ,KAAK7J,EAAW8K;AACZ,mBAAO;UACX,KAAK9K,EAAW+K;QAAAA;AAOpB,eAAO7K,EAAYc;MAAE,GAEzBgK,aAAa,MAAA;AACT,cAAMtH,KAAO,oBAAIY;AAOjB,gBANcZ,GAAKuH,YAAAA,IAAgB,QAAQ,OAO9B,KANCvH,GAAKwH,SAAAA,IAAa,KAOlB,KANFxH,GAAKyH,OAAAA,KAOL,KANCzH,GAAK0H,SAAAA,KAOL,KANE1H,GAAK2H,WAAAA,KAOL,IANA3H,GAAK4H,WAAAA,KAAgB;MAO1B,EAAA,EAAA;IAI1B,EA8kBgD3J,IAAQ0H,IAAMK,GAAaP,UAAAA,GAC7DoC,KAAAA,MA1qBdC,eAAuB7B,IAAmCL,IAAAA;AACtD,YAAMmC,MAAUnC,MAAAA,gBAAAA,GAASJ,kBAAiB5I,IAAgBI;AAC1D,UAAsB,eAAA,OAAXgL,OACP,QAAA,MAAanC,YAAYoC,qBAAqBC,MAAMH,EAAAA,GAAU9B,EAAAA;AAC3D;AACH,cAAA,EAAMkC,UAAEA,GAAAA,IAAAA,MAAmBC,OAAO,wBAAA,GAAA,EAC5BC,eAAEA,GAAAA,IAAAA,MAAwBD,OAAO,wBAAA,GACjCE,KAAAA,MAAiBH,GAASE,GAAcN,EAAAA,CAAAA;AAC9C,eAAA,MAAalC,YAAY0C,YAAYD,IAAUrC,EAAAA;MAAAA;IAEvD,EAgqBqCA,IAAcD,EAAAA,GACrC9H,KAAU2J,GAAOW,SAAStK,SAC1BR,KAAU,IAAIM,EAAmBC,IAAQC,EAAAA;AAC/C,WAAO8H,GAAaR,iBACd,IAAIiD,EAAuB/K,IAASQ,EAAAA,IACpC,IAAIwH,GAAUhI,IAASQ,EAAAA;EAAAA;EAmBjC,KAAKuF,IAAAA;AACD9F,uBAAAA,KAAc2E,WAAW1C,CAAAA,OAAAA;AACrB,YAAM8I,KAAU9I,GAAME,aAAY2D,MAAAA,gBAAAA,GAAKkF,SAAQ,EAAA;AAC/C,UAAIC,KAAS;AACb,UAAI,QAAOnF,IAAqC;AAC5CmF,QAAAA,KAAShJ,GAAMhB,MAAM,EAAA;AACrB,cAAMd,KAAOH,mBAAAA,KAAcG;AAC3BA,QAAAA,GAAK+K,SAASD,KAAQnF,MAAAA,gBAAAA,GAAKqF,QAAO,CAAA,GAClChL,GAAK+K,SAASD,KAAS,IAAGnF,MAAAA,gBAAAA,GAAKsF,SAAQ,CAAA,GACvCjL,GAAKqJ,UAAUyB,KAAS,IAAGnF,MAAAA,gBAAAA,GAAKuF,UAAS,GAAA,IAAG,GAC5ClL,GAAKqJ,UAAUyB,KAAS,IAAGnF,MAAAA,gBAAAA,GAAKwF,UAAS,GAAA,IAAG,GAC5CnL,GAAKqJ,UAAUyB,KAAS,KAAInF,MAAAA,gBAAAA,GAAKyF,WAAU,GAAA,IAAG;MAAA;AAElD,YAAMC,KAAcvJ,GAAMhB,MAAM,IAAA;AAChC3B,QACI,mBACA,MAAMU,mBAAAA,KAAcyL,OAAOV,IAASE,IAAQO,IAAa,IAAA,CAAA;IAC5D,CAAA;EAAA;EAcT,MAAMR,IAAelF,IAAAA;AACjB,UAAMvE,KAAUD,CAAAA,OAAiBtB,mBAAAA,KAAciB,MAAMK,EAAAA;AACrD,WAAOtB,mBAAAA,KAAc2E,WAAW1C,CAAAA,OAAAA;AAC5B,YAAMyJ,KAAQnK,GA/uBH,GAAA;AAgvBX,eAASoK,KAAI,GAAGA,KAhvBL,KAgvByBA,KAChC3L,oBAAAA,KAAcQ,KAAKkL,KAAQC,EAAAA,IAAK;AACpC,YAAMZ,KAAU9I,GAAME,YAAY6I,MAAQ,EAAA;AAM1C,aALA1L,EACI,sBACA,MAAMU,mBAAAA,KAAc4L,QAAQF,IAAOX,IAASjF,MAAO,CAAA,GACnD,MAAM9F,mBAAAA,KAAcwB,KAAKkK,EAAAA,CAAAA,GAEtB,IAAI7L,EAAY6L,IAAO1L,mBAAAA,IAAKD;IAAS,CAAA;EAAA;EAUpD,QAAQiL,IAAAA;AACJ,WAAOhL,mBAAAA,KAAc2E,WAAW1C,CAAAA,OAAAA;AAE5B,UAAA;AACI,cAAM8I,KAAU9I,GAAME,YAAY6I,MAAQ,EAAA;AAC1C1L,UACI,wBACA,MAAMU,mBAAAA,KAAc4L,QAAQ,GAAGb,IAAS,CAAA,CAAA;MAAA,UAEtC;MAAA;IAAA,CAAA;EAAA;EAelB,KAAKC,IAAca,IAAAA;AACf,WAAO7L,mBAAAA,KAAc2E,WAAW1C,CAAAA,OAAAA;AAC5B,YAAM8I,KAAU9I,GAAME,YAAY6I,EAAAA,GAC5Bc,KAAQ9L,mBAAAA,KAAciB,MAAM,GAAA;AAMlC,aALA3B,EACI,gBACA,MAAMU,mBAAAA,KAAc+L,OAAOD,IAAOf,IAASc,EAAAA,GAC3C,MAAM7L,mBAAAA,KAAcwB,KAAKsK,EAAAA,CAAAA,GAEtB,IAAI1H,EAAU0H,IAAO9L,mBAAAA,MAAeA,mBAAAA,IAAKD;IAAS,CAAA;EAAA;EAUjE,QAA6BP,IAAWwL,KAAe,IAAA;AACnDhL,SAAKgM,MAAMhB,EAAAA;AACX,QAAA;AACI,aAAOxL,GAAAA;IAAAA,UACD;AACNQ,WAAKiM,QAAQjB,EAAAA;IAAAA;EAAAA;EASrB,SAASA,IAAAA;AACL,UAAMkB,KAAOlM,KAAKmM,KAAKnB,EAAAA,GACjBtL,KAAS,IAAIe,WAAWyL,GAAK5K,IAAAA,GAC7B8K,KAAOpM,KAAKqM,KAAKrB,IAAMjM,EAAUuN,IAAAA;AACvC,QAAA;AAEI,aADAF,GAAKlF,KAAKxH,EAAAA,GACHA;IAAAA,UACD;AACN0M,MAAAA,GAAKjH,MAAAA;IAAAA;EAAAA;EASb,UAAU6F,IAAcuB,IAAAA;AACpB,UAAMH,KAAOpM,KAAKqM,KAAKrB,IAAMjM,EAAUyN,QAAQzN,EAAU0N,WAAAA;AACzD,QAAA;AACIL,MAAAA,GAAKM,MAAMH,EAAAA;IAAAA,UACL;AACNH,MAAAA,GAAKjH,MAAAA;IAAAA;EAAAA;EAUb,QAAQ6F,IAAAA;AACJ,WAAOhL,mBAAAA,KAAc2E,WAAW1C,CAAAA,OAAAA;AAC5B,YAAM8I,KAAU9I,GAAME,YAAY6I,EAAAA,GAC5B2B,KAAQ3M,mBAAAA,KAAciB,MA51BvB,EAAA;AAk2BL,aALA3B,EACI,qBACA,MAAMU,mBAAAA,KAAc4M,UAAUD,IAAO5B,EAAAA,GACrC,MAAM/K,mBAAAA,KAAcwB,KAAKmL,EAAAA,CAAAA,GAEtB,IAAI7F,EAAS6F,IAAO3M,mBAAAA,MAAeA,mBAAAA,IAAKD;IAAS,CAAA;EAAA;EAUhE,UAAUiL,IAAc6B,IAAAA;AACpB,WAAO7M,mBAAAA,KAAc2E,WAAW1C,CAAAA,OAAAA;AAC5B,YAAM8I,KAAU9I,GAAME,YAAY6I,EAAAA,GAC5B8B,KAAa7K,GAAME,YAAY0K,EAAAA,GAC/B1F,KAAMlF,GAAMhB,MAAMjC,CAAAA,GAClB2N,KAAQ3M,mBAAAA,KAAciB,MAj3BvB,EAAA;AAk3BL3B,QACI,uBACA,MAAMU,mBAAAA,KAAc+M,YAAYJ,IAAOxF,IAAK4D,IAAS+B,EAAAA,CAAAA;AAEzD,YAAMzF,KAAUrH,mBAAAA,KAAcQ,KAAKY,SAAS+F,IAAKA,KAAMnI,CAAAA;AACvD,aAAO,CACH,IAAI8H,EAAS6F,IAAO3M,mBAAAA,MAAeA,mBAAAA,IAAKD,GACxCqC,EAAckF,YAAYD,EAAAA,CAAAA;IAC7B,CAAA;EAAA;EAWT,CAAA,KAAM2D,IAAc6B,IAAAA;AAChB,QAAIG,IACArF;AAEJ,SAAA,CADCqF,IAAKrF,EAAAA,IAAY3H,KAAKiN,UAAUjC,IAAM6B,EAAAA,GACd,OAAlBlF,GAASpF,OAAAA,OACNoF,IACNA,KAAWqF,GAAIzF,SAAAA;EAAAA;EAWvB,KAAKyD,IAAAA;AACD,WAAOhL,mBAAAA,KAAc2E,WAAW1C,CAAAA,OAAAA;AAC5B,YAAM8I,KAAU9I,GAAME,YAAY6I,EAAAA,GAC5B7D,KAAMlF,GAAMhB,MAAMjC,CAAAA;AACxBM,QACI,4BACA,MAAMU,mBAAAA,KAAckN,OAAOnC,IAAS5D,EAAAA,CAAAA;AAExC,YAAME,KAAUrH,mBAAAA,KAAcQ,KAAKY,SAAS+F,IAAKA,KAAMnI,CAAAA;AACvD,aAAOoD,EAAckF,YAAYD,EAAAA;IAAQ,CAAA;EAAA;EASjD,OAAO2D,IAAAA;AACHhL,uBAAAA,KAAc2E,WAAW1C,CAAAA,OAAAA;AACrB,YAAM8I,KAAU9I,GAAME,YAAY6I,EAAAA;AAClC1L,QACI,8BACA,MAAMU,mBAAAA,KAAcmN,SAASpC,EAAAA,CAAAA;IAChC,CAAA;EAAA;EAeT,OAAOqC,IAAiBC,IAAAA;AACpBrN,uBAAAA,KAAc2E,WAAW1C,CAAAA,OAAAA;AACrB,YAAMqL,KAAarL,GAAME,YAAYiL,EAAAA,GAC/BG,KAAatL,GAAME,YAAYkL,EAAAA;AACrC/N,QACI,8BACA,MAAMU,mBAAAA,KAAcwN,SAASF,IAAYC,EAAAA,CAAAA;IAC5C,CAAA;EAAA;EAeT,MAAMvC,IAAcyC,IAAcC,IAAAA;AAC9B1N,uBAAAA,KAAc2E,WAAW1C,CAAAA,OAAAA;AACrB,YAAM8I,KAAU9I,GAAME,YAAY6I,EAAAA;AAClC1L,QACI,0CACA,MAAMU,mBAAAA,KAAc2N,QAAQ5C,IAAS0C,IAAMC,EAAAA,CAAAA;IAC9C,CAAA;EAAA;EAaT,MAAM1C,IAAc4C,IAAAA;AAChB5N,uBAAAA,KAAc2E,WAAW1C,CAAAA,OAAAA;AACrB,YAAM8I,KAAU9I,GAAME,YAAY6I,EAAAA,GAC5B7D,KAAMlF,GAAMhB,MAAM,EAAA,GAMlB2B,MAHQgL,GAAKhE,YAAAA,IAAgB,OAAQ,QAGd,IAFfgE,GAAK/D,SAAAA,IAAa,KAEY,IADhC+D,GAAK9D,OAAAA;AAEjB9J,yBAAAA,KAAcG,KAAKmJ,UAAUnC,KAAM,GAAGvE,IAAAA,IAAa;AAEnD,YAGMI,KAHO4K,GAAK7D,SAAAA,KAGW,KAFd6D,GAAK5D,WAAAA,KAE0B,IAD9B4D,GAAK3D,WAAAA,MAAiB;AAEtCjK,yBAAAA,KAAcG,KAAKmJ,UAAUnC,KAAM,GAAGnE,IAAAA,IAAa,GAEnD1D,EACI,2CACA,MAAMU,mBAAAA,KAAc6N,QAAQ9C,IAAS5D,EAAAA,CAAAA;IACxC,CAAA;EAAA;EAST,MAAM6D,IAAAA;AACchL,uBAAAA,KAAc8N,SAC9B9N,mBAAAA,KAAc2E,WAAW1C,CAAAA,OAAAA;AACrB,YAAM8I,KAAU9I,GAAME,YAAY6I,EAAAA;AAClC1L,QACI,sBACA,MAAMU,mBAAAA,KAAc8N,QAAQ/C,EAAAA,CAAAA;IAC/B,CAAA;EAAA;EAST,MAAMC,IAAAA;AACFhL,uBAAAA,KAAc2E,WAAW1C,CAAAA,OAAAA;AACrB,YAAM8I,KAAU9I,GAAME,YAAY6I,EAAAA;AAClC1L,QACI,8BACA,MAAMU,mBAAAA,KAAc+N,QAAQhD,EAAAA,CAAAA;IAC/B,CAAA;EAAA;EAST,QAAQC,IAAAA;AACJhL,uBAAAA,KAAc2E,WAAW1C,CAAAA,OAAAA;AACrB,YAAM8I,KAAU9I,GAAME,YAAY6I,EAAAA;AAClC1L,QACI,0BACA,MAAMU,mBAAAA,KAAcgO,UAAUjD,EAAAA,CAAAA;IACjC,CAAA;EAAA;EAST,SAAAkD;AACI,WAAOjO,mBAAAA,KAAc2E,WAAW1C,CAAAA,OAAAA;AAC5B,YAAMvB,KAASuB,GAAMhB,MAAM,GAAA;AAK3B,aAJA3B,EACI,6BACA,MAAMU,mBAAAA,KAAckO,SAASxN,IAAQ,GAAA,CAAA,GAElCV,mBAAAA,KAAckG,aAAaxF,IAAQ,GAAA;IAAI,CAAA;EAAA;EAWtD,QAAQsK,IAAAA;AACJ,WAAOhL,mBAAAA,KAAc2E,WAAW1C,CAAAA,OAAAA;AAC5B,YAAM8I,KAAU9I,GAAME,YAAY6I,MAAQ,EAAA,GACpCmD,KAAQlM,GAAMhB,MAAM,CAAA,GACpBmN,KAAWnM,GAAMhB,MAAM,CAAA;AAK7B,aAJA3B,EACI,+BACA,MAAMU,mBAAAA,KAAcqO,UAAUtD,IAASoD,IAAOC,EAAAA,CAAAA,GAE3C,CACHpO,mBAAAA,KAAcG,KAAKwC,UAAUwL,IAAAA,IAAO,GACpC,IAAItO,EAAYuO,IAAUpO,mBAAAA,IAAKD,CAAAA;IAClC,CAAA;EAAA;EAYT,SAASiL,IAAAA;AACL,WAAOhL,mBAAAA,KAAc2E,WAAW1C,CAAAA,OAAAA;AAC5B,YAAM8I,KAAU9I,GAAME,YAAY6I,MAAQ,EAAA,GACpCsD,KAAQrM,GAAMhB,MAAM,EAAA;AAC1BjB,yBAAAA,KAAcQ,KAAK8N,KAAQ,EAAA,IAAM;AACjC,YAAMC,KAAMtM,GAAMhB,MAAM,CAAA;AAKxB,aAJA3B,EACI,wBACA,MAAMU,mBAAAA,KAAcwO,WAAWzD,IAASuD,IAAOC,EAAAA,CAAAA,GAE5C,CACHvO,mBAAAA,KAAckG,aAAaoI,IAAO,EAAA,GAClCtO,mBAAAA,KAAcG,KAAKwC,UAAU4L,IAAAA,IAAK,CAAA;IACrC,CAAA;EAAA;EAST,SAASD,IAAAA;AACLtO,uBAAAA,KAAc2E,WAAW1C,CAAAA,OAAAA;AACrB,YAAMwM,KAAWxM,GAAME,YAAYmM,EAAAA;AACnChP,QACI,wBACA,MAAMU,mBAAAA,KAAc0O,WAAWD,EAAAA,CAAAA;IAClC,CAAA;EAAA;EAQT,MAAME,IAAAA;AACF,UAAMC,KAAU5O,mBAAAA,KAAc4O;AAC9BtP,MACI,4BACA,MAAMsP,GAAQD,EAAAA,CAAAA;EAAAA;AAAAA;AA9etB5O,MAAAA;AACAQ,MAAAA;AA3pBwB,IAypBfwH,IAzpBe;;AAkpCtB,IAAO+C,IAAP,cAAsC/C,EAAAA;EAOxC,YACIhI,IACAQ,IAAAA;AAEAyD,UAAMjE,IAASQ,EAAAA;AAVnBR,uBAAAA;AACAQ,uBAAAA;AAUIP,uBAAAA,KAAgBD,KAChBC,mBAAAA,KAAgBO;EAAAA;EAUpB,MAAMsO,IAAgBlG,IAAAA;AAClB3I,uBAAAA,KAAc2E,WAAW1C,CAAAA,OAAAA;AACrB,YAAMuJ,KAAcvJ,GAAMhB,MA5qCpB,GAAA,GA6qCA6N,KAAU7M,GAAMhB,MAAoB,IAAd4N,GAAK3N,MAAAA;AACjC,eAASyK,KAAI,GAAGA,KAAIkD,GAAK3N,QAAQyK,KAC7B3L,oBAAAA,KAAcG,KAAKqJ,UAAUsF,KAAe,IAAJnD,IAAQkD,GAAKlD,EAAAA,CAAAA;AACzDrM,QACI,qBACA,MAAMU,mBAAAA,KAAc+O,QAAQpG,MAAQ,GAAGmG,IAAStD,EAAAA,CAAAA;IACnD,CAAA;EAAA;AAAA;AA/BTzL,MAAAA;AACAQ,MAAAA;",
  "names": ["FatFsIoctl", "FatFsFormat", "FatFsResult", "FatFsAttrib", "FatFsMode", "SIZE_FILINFO", "singleWasmUrl", "URL", "url", "href", "multiWasmUrl", "throwIfError", "actionName", "action", "onError", "result", "OK", "FatFsError", "FatFsObject", "fatFsPtr", "context", "this", "ptr", "cSize", "view", "getUint16", "FatFsMemoryContext", "memory", "exports", "heap", "Uint8Array", "buffer", "DataView", "text", "textBytes", "TextEncoder", "encode", "textPtr", "alloc", "length", "textArray", "subarray", "set", "size", "malloc", "free", "ptrArray", "zeroIndex", "indexOf", "ptrTrimmed", "TextDecoder", "decode", "callback", "resources", "scope", "unshift", "allocString", "FatFsFileInfo", "date", "attrib", "name", "data", "byteOffset", "byteLength", "getUint32", "encodedDate", "year", "month", "day", "encodedTime", "Date", "nameArray", "nameTrimmed", "isReadOnly", "RDO", "isDirectory", "DIR", "isHidden", "HID", "isArchive", "ARC", "isSystem", "SYS", "Error", "errorCode", "super", "Object", "setPrototypeOf", "prototype", "FatFsFile", "filePtr", "fp", "buff", "btr", "f_read", "bytesToRead", "enterScope", "buffPtr", "brPtr", "bytesRead", "btw", "bytesToWrite", "bwPtr", "f_write", "close", "f_close", "sync", "f_sync", "ofs", "f_lseek", "rewind", "lseek", "truncate", "f_truncate", "fsz", "opt", "f_expand", "maxSize", "f_gets", "decodeString", "chr", "chrCode", "f_putc", "str", "f_puts", "strPtr", "tell", "f_tell", "f_eof", "f_size", "f_error", "FatFsDir", "dirPtr", "dp", "f_closedir", "read", "fno", "f_readdir", "fnoData", "fromFilInfo", "findNext", "f_findnext", "Symbol", "iterator", "fileInfo", "FATFS_DISK_OPTION_DEFAULTS", "multiPartition", "sectorSize", "FatFsDisk", "disk", "options", "WebAssembly", "Memory", "initial", "validOptions", "importObject", "ss", "sectorCount", "env", "disk_initialize", "pdrv", "disk_status", "disk_read", "sector", "count", "src", "disk_write", "disk_ioctl", "cmd", "CTRL_SYNC", "GET_SECTOR_SIZE", "setUint16", "GET_SECTOR_COUNT", "setUint32", "GET_BLOCK_SIZE", "CTRL_TRIM", "get_fattime", "getFullYear", "getMonth", "getDay", "getHours", "getMinutes", "getSeconds", "source", "async", "wasmUrl", "window", "instantiateStreaming", "fetch", "readFile", "import", "fileURLToPath", "wasmData", "instantiate", "instance", "FatFsDiskPartitionable", "pathPtr", "path", "optPtr", "setUint8", "fmt", "nFat", "align", "nRoot", "auSize", "workAreaPtr", "f_mkfs", "fsPtr", "i", "f_mount", "mode", "fpPtr", "f_open", "mount", "unmount", "info", "stat", "file", "open", "READ", "contents", "WRITE", "OPEN_ALWAYS", "write", "dpPtr", "f_opendir", "pattern", "patternPtr", "f_findfirst", "dir", "findFirst", "f_stat", "f_unlink", "oldName", "newName", "oldNamePtr", "newNamePtr", "f_rename", "attr", "mask", "f_chmod", "time", "f_utime", "f_mkdir", "f_chdir", "f_chdrive", "getcwd", "f_getcwd", "nclst", "fatfsPtr", "f_getfree", "label", "vsn", "f_getlabel", "labelPtr", "f_setlabel", "cp", "f_setcp", "ptbl", "ptblPtr", "f_fdisk"]
}
