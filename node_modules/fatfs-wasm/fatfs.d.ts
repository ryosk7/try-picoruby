/**
 * High-level interface for creating and accessing FAT images using the FatFS library by CHaN.
 * @module fatfs-wasm
 */
/** Disk I/O control commands (for disk_ioctl) */
export declare enum FatFsIoctl {
    CTRL_SYNC = 0,
    GET_SECTOR_COUNT = 1,
    GET_SECTOR_SIZE = 2,
    GET_BLOCK_SIZE = 3,
    CTRL_TRIM = 4
}
/** Format options (2nd argument of f_mkfs) */
export declare enum FatFsFormat {
    FAT = 1,
    FAT32 = 2,
    EXFAT = 4,
    ANY = 7,
    SFD = 8
}
export declare enum FatFsResult {
    OK = 0,/** (0) Succeeded */
    DISK_ERR = 1,/** (1) A hard error occurred in the low level disk I/O layer */
    INT_ERR = 2,/** (2) Assertion failed */
    NOT_READY = 3,/** (3) The physical drive cannot work */
    NO_FILE = 4,/** (4) Could not find the file */
    NO_PATH = 5,/** (5) Could not find the path */
    INVALID_NAME = 6,/** (6) The path name format is invalid */
    DENIED = 7,/** (7) Access denied due to prohibited access or directory full */
    EXIST = 8,/** (8) Access denied due to prohibited access */
    INVALID_OBJECT = 9,/** (9) The file/directory object is invalid */
    WRITE_PROTECTED = 10,/** (10) The physical drive is write protected */
    INVALID_DRIVE = 11,/** (11) The logical drive number is invalid */
    NOT_ENABLED = 12,/** (12) The volumeF has no work area */
    NO_FILESYSTEM = 13,/** (13) There is no valid FAT volume */
    MKFS_ABORTED = 14,/** (14) The f_mkfs() aborted due to any problem */
    TIMEOUT = 15,/** (15) Could not get a grant to access the volume within defined period */
    LOCKED = 16,/** (16) The operation is rejected according to the file sharing policy */
    NOT_ENOUGH_CORE = 17,/** (17) LFN working buffer could not be allocated */
    TOO_MANY_OPEN_FILES = 18,/** (18) Number of open files > FF_FS_LOCK */
    INVALID_PARAMETER = 19 /** (19) Given parameter is invalid */
}
/** File attribute bits for directory entry (FILINFO.fattrib) */
export declare enum FatFsAttrib {
    RDO = 1,
    HID = 2,
    SYS = 4,
    DIR = 16,
    ARC = 32
}
/** File modes */
export declare enum FatFsMode {
    /**
     * Specifies read access to the file. Data can be read from the file.
     */
    READ = 1,
    /**
     * Specifies write access to the file. Data can be written to the file.
     * Combine with FA_READ for read-write access.
     */
    WRITE = 2,
    /**
     * Opens a file. The function fails if the file is not existing. (Default)
     */
    OPEN_EXISTING = 0,
    /**
     * Creates a new file. The function fails with FR_EXIST if the file is
     * existing.
     */
    CREATE_NEW = 4,
    /**
     * Creates a new file. If the file is existing, it will be truncated and
     * overwritten.
     */
    CREATE_ALWAYS = 8,
    /**
     * Opens the file if it is existing. If not, a new file will be created.
     */
    OPEN_ALWAYS = 16,
    /**
     * Same as FA_OPEN_ALWAYS except the read/write pointer is set end of the
     * file.
     */
    OPEN_APPEND = 48
}
type FatFsExports = {
    malloc: (size: number) => number;
    free: (ptr: number) => void;
    f_fdisk: (pdrv: number, ptbl: number, work: number) => number;
    f_mkfs: (path: number, opt: number, work: number, len: number) => number;
    f_mount: (fs: number, path: number, opt: number) => number;
    f_open: (fp: number, path: number, mode: number) => number;
    f_read: (fp: number, buff: number, btr: number, br: number) => number;
    f_write: (fp: number, buff: number, btw: number, bw: number) => number;
    f_close: (fp: number) => number;
    f_sync: (fp: number) => number;
    f_lseek: (fp: number, ofs: number) => number;
    f_truncate: (fp: number) => number;
    f_expand: (fp: number, fsz: number, opt: number) => number;
    f_gets: (buff: number, len: number, fp: number) => number;
    f_putc: (chr: number, fp: number) => number;
    f_puts: (str: number, fp: number) => number;
    f_tell: (fp: number) => number;
    f_eof: (fp: number) => number;
    f_size: (fp: number) => number;
    f_error: (fp: number) => number;
    f_opendir: (dp: number, path: number) => number;
    f_closedir: (dp: number) => number;
    f_readdir: (dp: number, fno: number) => number;
    f_findfirst: (dp: number, fno: number, path: number, pattern: number) => number;
    f_findnext: (dp: number, fno: number) => number;
    f_stat: (path: number, fno: number) => number;
    f_unlink: (path: number) => number;
    f_rename: (oldName: number, newName: number) => number;
    f_chmod: (path: number, attr: number, mask: number) => number;
    f_utime: (path: number, fno: number) => number;
    f_mkdir: (path: number) => number;
    f_chdir: (path: number) => number;
    f_chdrive: (path: number) => number;
    f_getcwd: (buff: number, len: number) => number;
    f_getfree: (path: number, nclst: number, fatfs: number) => number;
    f_getlabel: (path: number, label: number, vsn: number) => number;
    f_setlabel: (label: number) => number;
    f_setcp: (cp: number) => number;
};
type HeapScope = {
    alloc: (size: number) => number;
    allocString: (text: string | null) => number;
};
/**
 * Options provided to {@link FatFsDisk.mkfs}
 */
export type FatFsMkfsOptions = {
    /** Format option (FM_FAT, FM_FAT32, FM_EXFAT and FM_SFD) */
    fmt?: FatFsFormat;
    /** Number of FATs */
    nFat?: number;
    /** Data area alignment (sector) */
    align?: number;
    /** Number of root directory entries */
    nRoot?: number;
    /** Cluster size (byte) */
    auSize?: number;
    /** Drive number to format. Empty string uses default drive */
    path?: string;
};
declare class FatFsObject {
    #private;
    constructor(fatFsPtr: number, context: FatFsMemoryContext);
    get ptr(): number;
    /**
     * Sectors per cluster
     */
    get cSize(): number;
}
declare class FatFsMemoryContext {
    #private;
    constructor(memory: WebAssembly.Memory, exports: FatFsExports);
    get heap(): Uint8Array<ArrayBuffer>;
    get view(): DataView<ArrayBuffer>;
    allocString(text: string | null): number;
    alloc(size: number): number;
    free(ptr: number): void;
    decodeString(buffer: number, size: number): string;
    enterScope<T>(callback: (scope: HeapScope) => T): T;
}
/**
 * Represents file or directory information returned from {@link FatFsDisk.stat} and iteration functions.
 */
export declare class FatFsFileInfo {
    /** The size of the file or directory */
    readonly size: number;
    /** The last modified date of the file or directory */
    readonly date: Date;
    /** File attribute flags (see is* methods to get specific flags) */
    readonly attrib: number;
    /** The name of the file or directory */
    readonly name: string;
    constructor(size: number, date: Date, attrib: number, name: string);
    /**
     * Creates a {@link FatFsFileInfo} from a packed FILINFO data structure returned from a FatFS function
     * @data Packed FILINFO structure bytes
     */
    static fromFilInfo(data: Uint8Array): FatFsFileInfo;
    /**
     * Whether or not the file or directory is read-only
     */
    get isReadOnly(): boolean;
    /**
     * Whether or not the filesystem object is a directory or not
     */
    get isDirectory(): boolean;
    /**
     * Whether or not the file or directory is hidden
     */
    get isHidden(): boolean;
    /**
     * Whether or not the file or directory is archived
     */
    get isArchive(): boolean;
    /**
     * Whether or not the file or directory is a system file or directory
     */
    get isSystem(): boolean;
}
/** Exception thrown when a FatFs export returns a non-OK result */
export declare class FatFsError extends Error {
    result: FatFsResult;
    constructor(action: string, errorCode: FatFsResult);
}
/**
 * FatFs file object
 */
export declare class FatFsFile {
    #private;
    constructor(filePtr: number, exports: FatFsExports, context: FatFsMemoryContext);
    /**
     * Low level pointer to the file descriptor
     */
    get fp(): number;
    /**
     * The f_read function reads data from a file.
     * @param buff Pointer to the buffer to store the read data.
     * @param btr Number of bytes to read in range of UINT type. If the file needs to be read fast, it should be read in large chunk as possible.
     * @returns number of bytes read
     */
    read(buff: Uint8Array, btr?: number): number;
    /**
     * The f_write writes data to a file.
     * @param buff Pointer to the data to be written.
     * @param btw Specifies number of bytes to write in range of UINT type. If
     *     the data needs to be written fast, it should be written in large
     *     chunk as possible.
     * @returns number of bytes written
     */
    write(buff: Uint8Array, btw?: number): number;
    /**
     * The f_close function closes an open file and destroys the file object.
     */
    close(): void;
    /**
     * The f_sync function flushes the cached information of a writing file.
     */
    sync(): void;
    /**
     * The f_lseek function moves the file read/write pointer of an open file
     * object. It can also be used to expand the file size
     * (cluster pre-allocation).
     * @param ofs Byte offset from top of the file to set read/write pointer.
     *     The data type FSIZE_t is an alias of either DWORD(32-bit) or
     *     QWORD(64-bit) depends on the configuration option FF_FS_EXFAT.
     */
    lseek(ofs: number): void;
    rewind(): void;
    /**
     * The f_truncate function truncates the file size to the current file
     * read/write pointer.
     */
    truncate(): void;
    /**
     * The f_expand function prepares or allocates a contiguous data area to
     * the file.
     * @param fsz Number of bytes in size to prepare or allocate for the file.
     *     The data type FSIZE_t is an alias of either DWORD(32-bit) or
     *     QWORD(64-bit) depends on the configuration option FF_FS_EXFAT.
     * @param opt Allocation mode. Prepare to allocate (0) or Allocate now (1).
     */
    expand(fsz: number, opt: number): void;
    /**
     * The f_gets reads a string from the file.
     * @returns the string
     */
    gets(maxSize: number): string;
    /**
     * The f_putc function puts a character to the file.
     * @param chr A code unit to write.
     * @returns When the character was written successfuly, it returns number
     *     of character encoding units written to the file. When the function
     *     failed due to disk full or any error, a negative value will be returned.
     */
    putc(chr: number): number;
    /**
     * The f_puts function writes a string to the file.
     * @param str Pointer to the null terminated string to be written. The
     *     terminator character will not be written.
     * @returns When the string was written successfuly, it returns number
     *     of character encoding units written to the file. When the function
     *     failed due to disk full or any error, a negative value will be
     *     returned.
     */
    puts(str: string): number;
    /**
     * The f_tell function gets the current read/write pointer of a file.
     * @returns Returns current read/write pointer of the file.
     */
    tell(): number;
    /**
     * The f_eof function tests for end-of-file on a file.
     * @returns The f_eof function returns a non-zero value
     *     if the read/write pointer has reached end of the file; otherwise it
     *     returns a zero.
     */
    eof(fp: FatFsFile): number;
    /**
     * The f_size function gets the size of a file.
     * @returns Returns the size of the file in unit of byte.
     */
    size(): number;
    /**
     * The f_error tests for an error on a file.
     * @returns Returns a non-zero value if a hard error has occured;
     *     otherwise it returns a zero.
     */
    error(fp: FatFsFile): number;
}
/**
 * FatFs Directory Reference
 */
export declare class FatFsDir {
    #private;
    constructor(dirPtr: number, exports: FatFsExports, context: FatFsMemoryContext);
    get dp(): number;
    /**
     * Closes the open directory.
     */
    close(): void;
    /**
     * Reads an item of the directory.
     * @returns Information about the next directory entry
     */
    read(): FatFsFileInfo;
    /**
     * Rewinds the directory
     */
    rewind(): void;
    /**
     * The f_findnext function searches for a next matched object
     */
    findNext(): FatFsFileInfo;
    [Symbol.iterator](): Iterator<FatFsFileInfo>;
}
/**
 * Options for creating a {@link FatFsDisk}.
 */
export type FatFsDiskOptions = {
    /** The size of the filesystem disk sectors, in bytes. Uses 512 if not provided. */
    sectorSize?: number;
    /** Whether or not to enable multi-partition disks, which enables {@link FatFsDiskPartitionable.fdisk} */
    multiPartition?: boolean;
};
/**
 * Represents a FAT filesystem over an array of bytes
 */
export declare class FatFsDisk {
    #private;
    /**
     * @overload
     * Create a new {@link FatFsDisk}.
     * @param disk Array of bytes containing a FAT image (or anything if you would like to format)
     * @param options Additional options. See {@link FatFsDiskOptions} for more information. Will return a {@link FatFsDiskPartitionable} if the `multiPartition` option is true.
     */
    static create(disk: Uint8Array, options: FatFsDiskOptions & {
        multiPartition: true;
    }): Promise<FatFsDiskPartitionable>;
    /**
     * @overload
     * Create a new {@link FatFsDisk}.
     * @param disk Array of bytes containing a FAT image (or anything if you would like to format)
     * @param options Additional options. See {@link FatFsDiskOptions} for more information. Will return a {@link FatFsDiskPartitionable} if the `multiPartition` option is true.
     */
    static create(disk: Uint8Array, options: FatFsDiskOptions): Promise<FatFsDisk>;
    /**
     * @overload
     * Create a new {@link FatFsDisk} with defaults
     * @param disk Array of bytes containing a FAT image (or anything if you would like to format)
     */
    static create(disk: Uint8Array): Promise<FatFsDisk>;
    /**
     * Private constructor. Use {@link FatFsDisk.create} to create a {@link FatFsDisk} object.
     */
    constructor(context: FatFsMemoryContext, exports: FatFsExports);
    /**
     * The f_mkfs function creates an FAT/exFAT volume on the logical drive.
     * @param opt Format options
     * @returns OK or error code
     */
    mkfs(opt?: FatFsMkfsOptions | null): void;
    /**
     * The f_mount function gives work area to the FatFs module.
     * @param path Pointer to the null-terminated string that specifies
     *     the logical drive. The string without drive number means the
     *     default drive.
     * @param opt Mounting option. 0: Do not mount now (to be mounted
     *     on the first access to the volume), 1: Force mounted the
     *     volume to check if it is ready to work.
     * @returns reference to the mounted work area
     */
    mount(path?: string, opt?: number): FatFsObject;
    /**
     * Unregisters the filesystem object
     * @param path Pointer to the null-terminated string that specifies
     *     the logical drive. The string without drive number means the
     *     default drive.
     */
    unmount(path?: string): void;
    /**
     * The f_open function opens a file.
     * @param path Pointer to the null-terminated string that specifies the
     *     file name to open or create.
     * @param mode Mode flags that specifies the type of access and open
     *     method for the file. It is specified by a combination of following
     *     flags.
     * @returns File object
     */
    open(path: string, mode: FatFsMode): FatFsFile;
    /**
     * Mounts the filesystem, executes a user function, and unmounts
     * @param action The action to perform
     * @param path The logical drive. An empty string without drive number
     *     means the default drive.
     */
    session<T extends () => any>(action: T, path?: string): ReturnType<T>;
    /**
     * Read an entire file.
     * @param path Path to the file to read
     * @returns The contents of the file
     */
    readFile(path: string): Uint8Array;
    /**
     * Write an entire file.
     * @param path Path to the file to write
     * @param contents Contents to write to the file
     */
    writeFile(path: string, contents: Uint8Array): void;
    /**
     * The f_opendir function opens a directory.
     * @param path Pointer to the null-terminated string that specifies the
     *     directory name to be opened.
     * @returns Directory object
     */
    openDir(path: string): FatFsDir;
    /**
     * Searches a directory for an item.
     * @param path The directory name to be opened.
     * @param pattern The pattern to search for
     * @returns The directory, and the first matching entry
     */
    findFirst(path: string, pattern: string): [FatFsDir, FatFsFileInfo];
    /**
     * Searches a directory
     *
     * @param path The directory name to be opened.
     * @param pattern The pattern to search for
     * @returns An iterator to the search results
     */
    find(path: string, pattern: string): IterableIterator<FatFsFileInfo>;
    /**
     * The f_stat function checks the existence of a file or sub-directory.
     * @param path Pointer to the null-terminated string that specifies the
     *     object to get its information. The object must not be the root
     *     direcotry.
     * @returns OK or error code
     */
    stat(path: string): FatFsFileInfo;
    /**
     * The f_unlink function removes a file or sub-directory from the volume.
     * @param path Pointer to a null-terminated string that specifies the file
     *     or sub-directory to be removed.
     */
    unlink(path: string): void;
    /**
     * The f_rename function renames and/or moves a file or sub-directory.
     * @param oldName Pointer to a null-terminated string that specifies the
     *     existing file or sub-directory to be renamed.
     * @param newName Pointer to a null-terminated string that specifies the
     *     new object name. A drive number may be specified in this string but
     *     it is ignored and assumed as the same drive of the old_name. Any
     *     object with this path name except old_name must not be exist, or the
     *     function fails with FR_EXIST.
     * @returns OK or error code
     */
    rename(oldName: string, newName: string): void;
    /**
     * The f_chmod function changes the attribute of a file or sub-directory.
     * @param path Pointer to the null-terminated string that specifies an
     *     object to be changed
     * @param attr Attribute flags to be set in one or more combination. The
     *     specified flags are set and others are cleared.
     * @param mask Attribute mask that specifies which attribute is changed.
     *     The specified attributes are set or cleared and others are left
     *     unchanged.
     * @returns OK or error code
     */
    chmod(path: string, attr: number, mask: number): void;
    /**
     * The f_utime function changes the timestamp of a file or sub-directory.
     * @param path Pointer to the null-terminated string that specifies an
     *     object to be changed.
     * @param time Pointer to the file information structure that has a
     *     timestamp to be set in member fdate and ftime. Do not care any
     *     other members.
     * @returns OK or error code
     */
    utime(path: string, time: Date): void;
    /**
     * The f_mkdir function creates a new directory.
     * @param path Pointer to the null-terminated string that specifies the
     *     directory name to create.
     */
    mkdir(path: string): void;
    /**
     * The f_chdir function changes the current directory of the logical drive.
     * @param path Pointer to the null-terminated string that specifies the
     *     directory to be set as current directory.
     */
    chdir(path: string): void;
    /**
     * The f_chdrive function changes the current drive.
     * @param path Specifies the logical drive number to be set as the current
     *     drive.
     */
    chdrive(path: string): void;
    /**
     * The f_getcwd function retrieves the current directory of the current
     * drive.
     * @returns The current directory.
     */
    getcwd(): string;
    /**
     *
     * @param path Pointer to the null-terminated string that specifies the
     *     logical drive. A null-string means the default drive.
     * @returns tuple with the number of free clusters, and a FATFS
     *     object containing number of sectors per cluster.
     */
    getFree(path?: string | null): [number, FatFsObject];
    /**
     * The f_getlabel function returns volume label and volume serial number
     * of a volume.
     * @param path Pointer to the null-terminated string that specifies the
     *     logical drive. Null-string specifies the default drive.
     * @returns tuple containing the result, the volume label, and the volume
     *     serial number
     */
    getLabel(path?: string): [string, number];
    /**
     * The f_setlabel function sets/removes the label of a volume.
     * @param label Pointer to the null-terminated string that specifies the
     *     volume label to be set.
     */
    setLabel(label: string): void;
    /**
     * The f_setcp function sets the active code page.
     * @param cp OEM code page to be used for the path name.
     */
    setCP(cp: number): void;
}
/**
 * Extension of {@link FatFsDisk} with extensions for partitioning a FAT drive with up to 4 partitions.
 *
 * If multi-partition support is enabled, accessing some types of FAT disks (e.g. floppes) may not work correctly.
 */
export declare class FatFsDiskPartitionable extends FatFsDisk {
    #private;
    /**
     * Private constructor. Use {@link FatFsDisk.create} with the `multiPartition` option set to true to create a {@link FatFsDiskPartitionable}.
     */
    constructor(context: FatFsMemoryContext, exports: FatFsExports);
    /**
     * The f_fdisk function divides a physical drive.
     * @param ptbl List of partition size to create on the drive.
     * @param pdrv Specifies the physical drive to be divided. This is not the
     *     logical drive number but the drive identifier passed to the low
     *     level disk functions.
     */
    fdisk(ptbl: number[], pdrv?: number): void;
}
export {};
//# sourceMappingURL=fatfs.d.ts.map